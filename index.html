<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COLOR - Lobby Split View</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
        
        body { 
            font-family: 'Montserrat', sans-serif; 
            background-color: #f0f0f0; 
            color: #1a1a1a;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Animations --- */
        @keyframes rainbowCycle {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes shine-pulse {
            0% { transform: scale(0.9); filter: brightness(1.5); box-shadow: 0 0 0 0 rgba(255,255,255,0.7); }
            50% { transform: scale(1.05); filter: brightness(1.2); box-shadow: 0 0 20px 5px rgba(255,255,255,0.5); }
            100% { transform: scale(1); filter: brightness(1); box-shadow: 0 0 0 0 rgba(255,255,255,0); }
        }
        @keyframes vanish-anim {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }
        @keyframes flip-anim {
            0% { transform: perspective(400px) rotateY(0); }
            50% { transform: perspective(400px) rotateY(90deg); filter: brightness(2); }
            100% { transform: perspective(400px) rotateY(0); }
        }

        .title-rainbow {
            background: linear-gradient(to right, #ff0000, #ff8800, #ffff00, #008000, #0000ff, #4b0082, #ee82ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% auto;
            animation: rainbowCycle 10s linear infinite;
        }

        .bg-waiting-rainbow {
            background: linear-gradient(45deg, #ff0000, #ffa500, #ffff00, #008000, #0000ff, #4b0082, #ee82ee, #ff0000);
            background-size: 400% 400%;
            animation: rainbowCycle 20s ease infinite;
        }

        .overwrite-box {
            width: 14px; height: 14px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            margin: 0 2px;
            transition: opacity 0.3s ease-out;
        }

        .bg-player-red { background-color: rgb(255, 0, 0); }
        .bg-player-yellow { background-color: rgb(255, 255, 0); }
        .bg-player-blue { background-color: rgb(0, 0, 255); }

        .text-player-red { color: rgb(255, 0, 0); }
        .text-player-yellow { color: rgb(210, 180, 0); } 
        .text-player-blue { color: rgb(0, 0, 255); }

        .breaker-shine { position: relative; overflow: hidden; }
        .breaker-shine::after {
            content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
            transform: skewX(-25deg); animation: subtle-shine 0.6s ease-out forwards; pointer-events: none;
        }
        @keyframes subtle-shine { 0% { left: -100%; opacity: 0; } 50% { opacity: 0.6; } 100% { left: 100%; opacity: 0; } }

        .cell { transition: transform 0.1s ease-in-out; }
        .cell:hover:not(.occupied-immutable) { filter: brightness(0.9); cursor: pointer; }
        
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .list-item { animation: slideIn 0.3s ease-out forwards; }

        .modal-content { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        /* Custom Checkbox */
        .invite-checkbox {
            appearance: none; background-color: #fff; margin: 0; font: inherit; color: currentColor;
            width: 1.15em; height: 1.15em; border: 2px solid currentColor; display: grid; place-content: center; cursor: pointer;
        }
        .invite-checkbox::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em black; transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .invite-checkbox:checked::before { transform: scale(1); }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d4d4d4; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-2 md:p-8" onclick="SoundManager.init()">

    <div id="game-container" class="w-full max-w-7xl bg-white shadow-2xl flex flex-col lg:flex-row min-h-[700px] border border-gray-300">
        
        <div class="flex-1 flex flex-col p-6 md:p-10 relative">
            
            <div class="mb-8 flex justify-between items-end">
                <h1 class="text-6xl md:text-7xl font-black tracking-tighter title-rainbow">COLOR</h1>
                <div id="desktop-timer-container" class="text-right hidden md:block">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TIMER</p>
                    <p class="text-5xl font-mono font-bold leading-none" id="timer-display">--</p>
                </div>
            </div>

            <div id="my-info-mobile" class="flex md:hidden justify-between items-end border-b-2 border-black pb-4 mb-6">
                <div>
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">PLAYER</p>
                    <p class="text-lg font-black uppercase tracking-tight truncate" id="my-nickname-mobile" style="color:#1a1a1a;">-</p>
                </div>
                <div id="mobile-timer-container" class="text-right">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TURN TIMER</p>
                    <p class="text-4xl font-mono font-bold leading-none" id="timer-display-mobile">--</p>
                </div>
            </div>

            <div class="flex-1 flex items-center justify-center min-h-[400px] mb-8">
                <div id="game-board" class="relative grid grid-cols-5 gap-px bg-gray-300 p-px w-full max-w-[600px] aspect-square border-2 border-gray-300 shadow-lg">
                    
                    <div id="waiting-screen" class="col-span-5 flex flex-col items-center justify-center h-full text-white bg-waiting-rainbow shadow-inner p-4 text-center">
                        <h2 class="text-3xl font-black uppercase tracking-widest mb-2 drop-shadow-md">WAITING FOR PLAYERS</h2>
                        <p id="room-status-text" class="text-lg font-bold drop-shadow-sm mb-6">...</p>
                        
                        <div id="host-controls" class="hidden flex flex-col gap-3 w-full max-w-xs animate-[popIn_0.3s_ease-out]">
                            <button id="host-start-btn" disabled 
                                    class="w-full bg-black hover:bg-gray-900 text-white border-2 border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all shadow-xl disabled:opacity-50 disabled:cursor-not-allowed">
                                WAITING FOR 3 PLAYERS...
                            </button>
                            <button id="host-start-ai-btn" class="hidden w-full bg-yellow-400 hover:bg-yellow-500 text-black border-2 border-black/10 font-black py-3 text-xs tracking-[0.15em] uppercase transition-all shadow-lg">
                                START WITH AI (2P + 1 BOT)
                            </button>
                        </div>
                        <p id="guest-waiting-msg" class="hidden text-sm font-bold opacity-80 mt-4 uppercase tracking-widest blink">Waiting for Host to start...</p>
                    </div>

                    <div id="message-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/30">
                        <div class="modal-content bg-white/20 border border-white/40 p-6 w-[80%] max-w-sm text-center backdrop-blur-md shadow-[0_8px_32px_0_rgba(31,38,135,0.37)] rounded-xl relative">
                            <button onclick="window.triggerRematch()" class="absolute top-2 right-3 text-white text-2xl font-bold p-1 leading-none hover:text-gray-300">&times;</button>
                            <h3 id="modal-title" class="text-2xl font-black uppercase mb-3 tracking-tighter text-white drop-shadow-md">TITLE</h3>
                            <p id="modal-content" class="text-white mb-6 font-bold whitespace-pre-line leading-relaxed text-sm drop-shadow-sm">Content</p>
                            <button id="modal-play-again" class="w-full bg-black hover:bg-gray-800 text-white border border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl mb-3">
                                PLAY AGAIN (SAME MEMBERS)
                            </button>
                        </div>
                    </div>

                    <div id="invite-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/50">
                        <div class="modal-content bg-white border border-gray-200 p-6 w-[80%] max-w-sm text-center shadow-2xl rounded-xl">
                            <h3 class="text-xl font-black uppercase mb-2 tracking-tighter text-black">INVITATION</h3>
                            <p id="invite-text" class="text-gray-600 mb-6 font-bold text-sm">Join room?</p>
                            <div class="flex gap-2">
                                <button id="accept-invite-btn" class="flex-1 bg-black text-white py-3 font-bold uppercase tracking-widest hover:bg-gray-800">YES</button>
                                <button id="decline-invite-btn" class="flex-1 bg-gray-200 text-black py-3 font-bold uppercase tracking-widest hover:bg-gray-300">NO</button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
            
            <div class="flex flex-col items-center mt-auto w-full">
                
                <div id="overwrite-ui-container" class="w-full max-w-[600px] flex justify-end items-center px-2 mb-4 hidden">
                    <p class="text-xs font-bold text-gray-500 uppercase tracking-widest mr-2">OVERWRITE</p>
                    <div id="overwrite-ui-display" class="flex items-center"></div>
                </div>

                <div class="flex flex-col gap-3 w-full max-w-md">
                    <div id="login-section" class="w-full">
                        <input type="text" id="nickname-input" placeholder="ENTER YOUR NICKNAME" maxlength="10" 
                               class="w-full bg-gray-100 border-2 border-gray-200 p-4 font-bold text-center uppercase tracking-widest focus:outline-none focus:border-black transition-colors mb-3">
                        <button id="login-btn" disabled
                                class="w-full bg-black text-white hover:bg-gray-800 font-bold py-4 text-sm tracking-widest uppercase transition-colors disabled:opacity-30 disabled:cursor-not-allowed">
                            ENTER LOBBY
                        </button>
                    </div>

                    <div id="lobby-section" class="hidden w-full flex flex-col gap-3">
                        <input type="text" id="room-title-input" placeholder="ROOM TITLE" maxlength="15" 
                               class="w-full bg-white border-2 border-gray-300 p-4 font-bold text-center uppercase tracking-widest focus:outline-none focus:border-black transition-colors">
                        
                        <button id="create-room-btn" disabled
                                class="w-full bg-gradient-to-r from-red-500 via-yellow-500 to-blue-500 text-white font-black py-4 text-sm tracking-widest uppercase transition-all shadow-lg hover:scale-[1.02] disabled:opacity-50 disabled:grayscale">
                            CREATE ROOM
                        </button>
                    </div>
                </div>
            </div>
            
            <span id="my-nickname-display" class="hidden"></span>
            <span id="my-color-display" class="hidden"></span>
        </div>

        <div class="w-full lg:w-96 bg-gray-50 border-t lg:border-t-0 lg:border-l border-gray-200 p-8 flex flex-col gap-6 h-screen lg:h-auto overflow-hidden">
            
            <div id="scores-section" class="hidden">
                <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-2">SCORES</p>
                <ul id="score-list" class="space-y-2"></ul>
            </div>

            <div id="lobby-lists-container" class="flex-1 flex flex-col gap-6 h-full hidden min-h-0">
                
                <div class="flex-1 flex flex-col min-h-0 border-b-2 border-gray-200 pb-4">
                    <div class="flex justify-between items-center mb-2">
                        <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">OPEN ROOMS</p>
                        <span id="room-list-count" class="text-xs font-bold bg-black text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="room-list-el" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        </div>
                </div>

                <div class="flex-1 flex flex-col min-h-0">
                    <div class="flex justify-between items-center mb-2">
                        <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">LOBBY PLAYERS</p>
                        <span id="player-list-count" class="text-xs font-bold bg-black text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="player-list-el" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        </div>
                    
                    <button id="host-invite-btn" class="hidden w-full bg-black text-white mt-3 py-3 text-xs font-bold uppercase tracking-widest hover:bg-gray-800 transition-colors">
                        INVITE SELECTED
                    </button>
                </div>
            </div>

        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, deleteField,
            query, where, getDocs, runTransaction, serverTimestamp, orderBy, limit, addDoc 
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Sound Manager ---
        window.SoundManager = {
            ctx: null,
            init: function() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.playAmbient();
                
                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        if (currentRoomId && !gameId) {
                            await leaveCurrentRoom(); 
                            resetToLobby(); 
                        }
                    }
                });
                window.addEventListener('beforeunload', () => {
                    if (currentRoomId && !gameId) leaveCurrentRoom();
                    if (userId && !currentRoomId) deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId));
                });
            },
            playAmbient: function() {
                const t = this.ctx.currentTime;
                const gain = this.ctx.createGain();
                gain.connect(this.ctx.destination);
                const freqs = [261.63, 329.63, 392.00, 493.88]; 
                freqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                    osc.frequency.value = f;
                    const oscGain = this.ctx.createGain();
                    oscGain.gain.value = 0.03; 
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.1 + (i * 0.05);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.01;
                    lfo.connect(lfoGain);
                    lfoGain.connect(oscGain.gain);
                    lfo.start();
                    osc.connect(oscGain);
                    oscGain.connect(gain);
                    osc.start();
                });
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.5, t + 5); 
            },
            playGlass: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(1500, t); osc.frequency.exponentialRampToValueAtTime(1500, t + 1); gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t + 0.01); gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(t); osc.stop(t + 1.5); const osc2 = this.ctx.createOscillator(); const gain2 = this.ctx.createGain(); osc2.type = 'triangle'; osc2.frequency.setValueAtTime(3000, t); gain2.gain.setValueAtTime(0, t); gain2.gain.linearRampToValueAtTime(0.05, t + 0.01); gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.0); gain2.connect(this.ctx.destination); osc2.start(t); osc2.stop(t + 1.0); },
            playConflict: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(50, t + 0.5); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.5); },
            playTick: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); const filter = this.ctx.createBiquadFilter(); osc.type = 'square'; filter.type = 'highpass'; filter.frequency.value = 2000; osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination); osc.frequency.setValueAtTime(800, t); gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05); osc.start(); osc.stop(t + 0.05); }
        };

        // --- Config ---
        const BOARD_SIZE = 5;
        const TURN_DURATION_MS = 5000; 
        const FIRST_TURN_DURATION_MS = 10000; 
        const NETWORK_BUFFER_MS = 1000;
        const MAX_OVERWRITES = 3; 
        const COLORS = ['R', 'Y', 'B']; 
        const COLOR_MAP = {
            'R': { code: 'bg-player-red', text: 'text-player-red', label: 'RED', html_color: 'rgb(255, 0, 0)' },
            'Y': { code: 'bg-player-yellow', text: 'text-player-yellow', label: 'YELLOW', html_color: 'rgb(210, 180, 0)' },
            'B': { code: 'bg-player-blue', text: 'text-player-blue', label: 'BLUE', html_color: 'rgb(0, 0, 255)' },
        };
        const firebaseConfig = {
            apiKey: "AIzaSyA1DEzZvw6_63cLUk_YeWYRInZ0drIzd5Q",
            authDomain: "color-a6d38.firebaseapp.com",
            projectId: "color-a6d38",
            storageBucket: "color-a6d38.firebasestorage.app",
            messagingSenderId: "761735384766",
            appId: "1:761735384766:web:cc52566ccafac650a558ef"
        };
        const appId = 'Color-Game-V7-Conflict';

        let app, db, auth, userId;
        let myNickname = "";
        let currentRoomId = null;
        let gameId = null;
        let myColor = null;
        let myOverwritesLeft = MAX_OVERWRITES;
        let lastProcessedTurn = 0; 
        let isAnimating = false; 
        let pendingBoardState = null; 
        let pendingGameEndData = null; 
        
        // Listeners
        let unsubscribeRooms = null; 
        let unsubscribePlayers = null;
        let unsubscribeCurrentRoom = null;
        let unsubscribeGame = null;
        let unsubscribeInvitation = null;

        let selectedInvitees = new Set();

        // UI Elements
        const nicknameInput = document.getElementById('nickname-input');
        const loginBtn = document.getElementById('login-btn');
        const loginSection = document.getElementById('login-section');
        const lobbySection = document.getElementById('lobby-section');
        const roomTitleInput = document.getElementById('room-title-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        
        // Right Panel (Split View)
        const lobbyListsContainer = document.getElementById('lobby-lists-container');
        const roomListCount = document.getElementById('room-list-count');
        const roomListEl = document.getElementById('room-list-el');
        const playerListCount = document.getElementById('player-list-count');
        const playerListEl = document.getElementById('player-list-el');
        const hostInviteBtn = document.getElementById('host-invite-btn');

        const boardElement = document.getElementById('game-board');
        const timerDisplay = document.getElementById('timer-display');
        const scoresSection = document.getElementById('scores-section');
        const scoreList = document.getElementById('score-list');
        const mobileTimerContainer = document.getElementById('mobile-timer-container');
        const myNicknameDisplay = document.getElementById('my-nickname-display');
        const myColorDisplay = document.getElementById('my-color-display'); 
        const myNicknameMobile = document.getElementById('my-nickname-mobile'); 
        const overwriteUIDisplay = document.getElementById('overwrite-ui-display');
        const overwriteUIContainer = document.getElementById('overwrite-ui-container');
        const waitingScreen = document.getElementById('waiting-screen');
        const roomStatusText = document.getElementById('room-status-text');

        // Host Controls
        const hostControls = document.getElementById('host-controls');
        const hostStartBtn = document.getElementById('host-start-btn');
        const hostStartAiBtn = document.getElementById('host-start-ai-btn');
        const guestWaitingMsg = document.getElementById('guest-waiting-msg');

        // Modal Elements
        const inviteModal = document.getElementById('invite-modal');
        const inviteText = document.getElementById('invite-text');
        const acceptInviteBtn = document.getElementById('accept-invite-btn');
        const declineInviteBtn = document.getElementById('decline-invite-btn');

        let currentBoardState = [];
        let selectedCell = null; 
        let isResolving = false;
        let localTimerInterval = null;
        let lastTimerValue = ""; 
        let isMoveCommitted = false; 

        // --- Strict Watchdog ---
        let lobbyKickTimer = null;
        const STRICT_QUEUE_TIMEOUT = 30000; 

        function startLobbyWatchdog() {
            resetLobbyWatchdog();
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.addEventListener(evt, resetLobbyWatchdog);
            });
        }
        function stopLobbyWatchdog() {
            if (lobbyKickTimer) clearTimeout(lobbyKickTimer);
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.removeEventListener(evt, resetLobbyWatchdog);
            });
        }
        function resetLobbyWatchdog() {
            if (lobbyKickTimer) clearTimeout(lobbyKickTimer);
            if (currentRoomId && !gameId) {
                lobbyKickTimer = setTimeout(async () => {
                    await leaveCurrentRoom();
                    resetToLobby();
                    alert("30s Inactivity: Returned to Lobby.");
                }, STRICT_QUEUE_TIMEOUT);
            }
        }

        async function init() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            try {
                const credential = await signInAnonymously(auth);
                userId = credential.user.uid; 
            } catch (error) { console.error("Auth failed:", error); }
            onAuthStateChanged(auth, (user) => { if (user && !userId) userId = user.uid; });
            mobileTimerContainer.classList.add('hidden');
            overwriteUIContainer.classList.add('hidden');
        }
        window.onload = init;

        // --- 1. Login & Lobby ---
        nicknameInput.addEventListener('input', (e) => loginBtn.disabled = e.target.value.trim().length === 0);
        loginBtn.addEventListener('click', async () => {
            const val = nicknameInput.value.trim();
            if(!val) return;
            myNickname = val.toUpperCase().slice(0, 10);
            if(window.SoundManager) window.SoundManager.init();
            
            // Register self in Queue
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), {
                userId: userId, nickname: myNickname, status: 'idle', joinedAt: serverTimestamp()
            });

            enterLobbyMode();
            watchMyInvitation(); 
        });

        function enterLobbyMode() {
            loginSection.classList.add('hidden');
            lobbySection.classList.remove('hidden');
            lobbyListsContainer.classList.remove('hidden');
            
            myNicknameDisplay.textContent = myNickname;
            myNicknameMobile.textContent = myNickname; 
            
            roomTitleInput.disabled = false;
            createRoomBtn.disabled = true;
            
            hostInviteBtn.classList.add('hidden'); // Hidden in lobby, visible when Host
            
            // Start watching BOTH lists
            watchRooms();
            watchLobbyPlayers();
        }

        function watchMyInvitation() {
            if (unsubscribeInvitation) return;
            unsubscribeInvitation = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    if (data.invitation) {
                        showInviteModal(data.invitation);
                    }
                }
            });
        }

        function showInviteModal(inviteData) {
            inviteText.textContent = `Invitation from room "${inviteData.roomTitle}"\n(Host: ${inviteData.hostName})`;
            inviteModal.classList.remove('hidden');

            acceptInviteBtn.onclick = async () => {
                inviteModal.classList.add('hidden');
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), { invitation: deleteField() });
                joinRoom(inviteData.roomId);
            };

            declineInviteBtn.onclick = async () => {
                inviteModal.classList.add('hidden');
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), { invitation: deleteField() });
            };
        }

        // --- 3. Room Creation & Host View ---
        roomTitleInput.addEventListener('input', (e) => createRoomBtn.disabled = e.target.value.trim().length === 0);
        createRoomBtn.addEventListener('click', async () => {
            const title = roomTitleInput.value.trim().toUpperCase().slice(0, 15);
            if (!title) return;
            
            createRoomBtn.textContent = "CREATING...";
            createRoomBtn.disabled = true;
            roomTitleInput.disabled = true;

            try {
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId));

                const roomDoc = await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'rooms'), {
                    title: title, hostId: userId, hostName: myNickname,
                    players: [{ userId: userId, nickname: myNickname }],
                    status: 'waiting', createdAt: serverTimestamp(), matchId: null
                });
                
                currentRoomId = roomDoc.id;
                enterWaitingRoomAsHost(title);

            } catch(e) { console.error(e); resetToLobby(); }
        });

        function enterWaitingRoomAsHost(title) {
            lobbySection.classList.add('hidden');
            waitingScreen.classList.remove('hidden');
            waitingScreen.querySelector('h2').textContent = title;
            
            // Host Controls Visible
            hostControls.classList.remove('hidden');
            guestWaitingMsg.classList.add('hidden');
            
            // Enable Invites in Player List
            hostInviteBtn.classList.remove('hidden');
            selectedInvitees.clear();
            
            // Ensure lists are still visible
            lobbyListsContainer.classList.remove('hidden');
            
            startLobbyWatchdog();
            watchCurrentRoom();
        }

        // --- 4. Room/Player List Logic (Combined) ---
        function watchRooms() {
            if (unsubscribeRooms) unsubscribeRooms();
            const roomsRef = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
            const q = query(roomsRef, where('status', '==', 'waiting'), orderBy('createdAt', 'desc'), limit(10));
            unsubscribeRooms = onSnapshot(q, (snapshot) => { renderRoomList(snapshot.docs); });
        }

        function renderRoomList(docs) {
            roomListCount.textContent = docs.length;
            roomListEl.innerHTML = '';
            if (docs.length === 0) {
                roomListEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-8 uppercase tracking-widest">No open rooms</p>';
                return;
            }
            docs.forEach(d => {
                const data = d.data();
                const playerCount = data.players ? data.players.length : 0;
                const isFull = playerCount >= 3;
                
                const el = document.createElement('div');
                el.className = "list-item p-3 border border-gray-200 bg-white flex justify-between items-center mb-2 shadow-sm transition hover:shadow-md";
                el.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-bold uppercase text-sm">${data.title}</span>
                        <span class="text-[10px] text-gray-500 tracking-widest">HOST: ${data.hostName || 'Unknown'}</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <span class="font-mono font-bold text-xs ${isFull ? 'text-red-500' : 'text-green-600'}">${playerCount}/3</span>
                        <button class="bg-black text-white px-4 py-2 text-xs font-bold uppercase tracking-widest hover:bg-gray-800 disabled:opacity-50"
                                onclick="window.joinRoom('${d.id}')" ${isFull ? 'disabled' : ''}>JOIN</button>
                    </div>`;
                roomListEl.appendChild(el);
            });
        }

        function watchLobbyPlayers() {
            if (unsubscribePlayers) unsubscribePlayers();
            const queueRef = collection(db, 'artifacts', appId, 'public', 'data', 'queue');
            const q = query(queueRef, orderBy('joinedAt', 'desc'), limit(20));
            unsubscribePlayers = onSnapshot(q, (snapshot) => { renderPlayerList(snapshot.docs); });
        }

        function renderPlayerList(docs) {
            const players = docs.filter(d => d.id !== userId);
            playerListCount.textContent = players.length;
            playerListEl.innerHTML = '';
            
            if (players.length === 0) {
                playerListEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-8 uppercase tracking-widest">No players in lobby</p>';
                return;
            }

            // Determine if I am a Host inside a room
            const isHostMode = (currentRoomId && !gameId && !hostControls.classList.contains('hidden'));

            players.forEach(d => {
                const data = d.data();
                const el = document.createElement('div');
                el.className = "list-item p-3 border border-gray-200 bg-white flex justify-between items-center mb-2 shadow-sm";
                
                let contentHTML = "";
                if (isHostMode) {
                    // Render with checkbox
                    const isChecked = selectedInvitees.has(d.id);
                    contentHTML = `
                        <div class="flex items-center gap-3">
                            <input type="checkbox" class="invite-checkbox" ${isChecked ? 'checked' : ''} onchange="window.toggleInvite('${d.id}')">
                            <span class="font-bold uppercase text-sm">${data.nickname}</span>
                        </div>
                        <span class="text-[10px] text-gray-400 tracking-widest">IDLE</span>
                    `;
                } else {
                    // Render simple list
                    contentHTML = `
                        <div class="flex items-center gap-3">
                            <span class="font-bold uppercase text-sm">${data.nickname}</span>
                        </div>
                        <span class="text-[10px] text-gray-400 tracking-widest">IDLE</span>
                    `;
                }
                
                el.innerHTML = contentHTML;
                playerListEl.appendChild(el);
            });
        }

        window.toggleInvite = (pid) => {
            if (selectedInvitees.has(pid)) selectedInvitees.delete(pid);
            else selectedInvitees.add(pid);
        };

        hostInviteBtn.addEventListener('click', async () => {
            if (!currentRoomId || selectedInvitees.size === 0) return;
            hostInviteBtn.textContent = "SENDING...";
            hostInviteBtn.disabled = true;
            const roomSnap = await getDocs(query(collection(db, 'artifacts', appId, 'public', 'data', 'rooms'), where('__name__', '==', currentRoomId)));
            const roomData = roomSnap.docs[0].data();
            const invitePromises = Array.from(selectedInvitees).map(targetId => {
                return updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', targetId), {
                    invitation: { roomId: currentRoomId, roomTitle: roomData.title, hostName: myNickname }
                });
            });
            await Promise.all(invitePromises);
            hostInviteBtn.textContent = "INVITE SENT";
            setTimeout(() => {
                hostInviteBtn.textContent = "INVITE SELECTED";
                hostInviteBtn.disabled = false;
                selectedInvitees.clear();
                // We don't manually clear checkboxes here because re-rendering might handle it, 
                // but for UX let's leave them. They will clear on next render loop if we clear set.
                // Actually renderPlayerList checks selectedInvitees.
                watchLobbyPlayers(); // Re-trigger render
            }, 2000);
        });

        // --- 5. Joining Room & Status ---
        window.joinRoom = async (roomId) => {
            if (!userId) return;
            try {
                lobbySection.classList.add('hidden');
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw "Room does not exist!";
                    const data = roomDoc.data();
                    if (data.players.length >= 3) throw "Room is full!";
                    const newPlayers = [...data.players, { userId: userId, nickname: myNickname }];
                    transaction.update(roomRef, { players: newPlayers });
                    transaction.delete(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId));
                });
                currentRoomId = roomId;
                const roomDoc = await getDocs(query(collection(db, 'artifacts', appId, 'public', 'data', 'rooms'), where('__name__', '==', roomId)));
                const roomTitle = roomDoc.docs[0]?.data().title || "ROOM";
                enterWaitingRoomAsGuest(roomTitle);
            } catch (e) { alert(e); resetToLobby(); }
        };

        function enterWaitingRoomAsGuest(title) {
            lobbySection.classList.add('hidden');
            waitingScreen.classList.remove('hidden');
            waitingScreen.querySelector('h2').textContent = title;
            roomStatusText.textContent = "Waiting for Host...";
            
            // Host Controls Hidden for Guests
            hostControls.classList.add('hidden');
            guestWaitingMsg.classList.remove('hidden');
            
            hostInviteBtn.classList.add('hidden'); // Guest cannot invite
            lobbyListsContainer.classList.remove('hidden'); // Guest still sees lists
            
            // Refresh player list to remove checkboxes
            watchLobbyPlayers();

            startLobbyWatchdog();
            watchCurrentRoom();
        }

        function watchCurrentRoom() {
            if (!currentRoomId) return;
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId);
            unsubscribeCurrentRoom = onSnapshot(roomRef, async (docSnap) => {
                if (!docSnap.exists()) { resetToLobby(); return; }
                const data = docSnap.data();
                const players = data.players || [];
                
                roomStatusText.innerHTML = `PLAYERS (${players.length}/3)<br><span class="text-sm font-normal opacity-80 mt-2 block">${players.map(p => p.nickname).join(', ')}</span>`;

                if (data.matchId) { enterGame(data.matchId); return; }

                // Host Controls Update
                if (data.hostId === userId) {
                    if (players.length === 3) {
                        hostStartBtn.textContent = "START GAME";
                        hostStartBtn.disabled = false;
                        hostStartBtn.onclick = () => startGameTransaction(players);
                        hostStartAiBtn.classList.add('hidden');
                    } else if (players.length === 2) {
                        hostStartBtn.textContent = "WAITING FOR 3RD...";
                        hostStartBtn.disabled = true;
                        hostStartAiBtn.classList.remove('hidden');
                        hostStartAiBtn.onclick = () => startWithAI(players);
                    } else {
                        hostStartBtn.textContent = "WAITING FOR PLAYERS...";
                        hostStartBtn.disabled = true;
                        hostStartAiBtn.classList.add('hidden');
                    }
                }
            });
        }

        async function startWithAI(players) {
            if (gameId) return;
            const aiPlayer = { userId: 'AI_BOT_' + Date.now(), nickname: 'AI BOT', isAI: true };
            const finalPlayers = [...players, aiPlayer];
            await startGameTransaction(finalPlayers);
        }

        async function startGameTransaction(players) {
            if (gameId) return; 
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const newGameRef = doc(gamesRef);
            const newGameId = newGameRef.id;
            
            const playersData = {};
            const playerOrder = [];
            players.forEach((p, idx) => {
                // If it's a generated AI object, use it directly. Otherwise use user data.
                playersData[p.userId] = { 
                    nickname: p.nickname, 
                    color: COLORS[idx], 
                    isAI: !!p.isAI, 
                    score: 0, 
                    overwrites: MAX_OVERWRITES, 
                    lastMove: null 
                };
                playerOrder.push(p.userId);
            });

            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;

            try {
                await runTransaction(db, async (transaction) => {
                    transaction.set(newGameRef, {
                        status: 'playing', turn: 1, turnDeadline: deadLine,
                        board: JSON.stringify(initialBoard), players: playersData,
                        playerOrder: playerOrder, hostId: userId, createdAt: serverTimestamp(),
                        lastRoundEvents: "[]"
                    });
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId);
                    transaction.update(roomRef, { matchId: newGameId, status: 'full' });
                });
            } catch (e) { console.error("Error starting game:", e); }
        }

        async function leaveCurrentRoom() {
            stopLobbyWatchdog();
            if (unsubscribeCurrentRoom) unsubscribeCurrentRoom();
            if (currentRoomId) {
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoomId);
                try {
                    await runTransaction(db, async (transaction) => {
                        const snap = await transaction.get(roomRef);
                        if (!snap.exists()) return;
                        const data = snap.data();
                        const newPlayers = data.players.filter(p => p.userId !== userId);
                        if (newPlayers.length === 0) transaction.delete(roomRef);
                        else transaction.update(roomRef, { players: newPlayers });
                    });
                } catch (e) { console.error(e); }
                currentRoomId = null;
            }
        }

        function resetToLobby() {
            stopLobbyWatchdog();
            if (localTimerInterval) clearInterval(localTimerInterval);
            if (unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
            if (unsubscribeCurrentRoom) { unsubscribeCurrentRoom(); unsubscribeCurrentRoom = null; }

            currentRoomId = null;
            gameId = null;
            
            setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), {
                userId: userId, nickname: myNickname, status: 'idle', joinedAt: serverTimestamp()
            });

            lobbySection.classList.remove('hidden');
            lobbyListsContainer.classList.remove('hidden');
            createRoomBtn.textContent = "CREATE ROOM";
            createRoomBtn.disabled = false;
            roomTitleInput.disabled = false;
            roomTitleInput.value = "";
            
            waitingScreen.classList.remove('hidden'); 
            waitingScreen.querySelector('h2').textContent = "LOBBY";
            roomStatusText.textContent = "";

            // Hide controls
            hostControls.classList.add('hidden');
            guestWaitingMsg.classList.add('hidden');

            scoresSection.classList.add('hidden');
            mobileTimerContainer.classList.add('hidden');
            overwriteUIContainer.classList.add('hidden');
            
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(el => el.remove());
            
            document.getElementById('message-modal').classList.add('hidden');
            inviteModal.classList.add('hidden');
            
            hostInviteBtn.classList.add('hidden');
            watchRooms();
            watchLobbyPlayers();
        }

        async function enterGame(id) {
            stopLobbyWatchdog();
            if (unsubscribeCurrentRoom) unsubscribeCurrentRoom(); 
            gameId = id;
            unsubscribeGame = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (docSnap) => {
                if(!docSnap.exists()) {
                    if(localTimerInterval) clearInterval(localTimerInterval);
                    resetToLobby();
                    return;
                }
                handleGameUpdate(docSnap.data());
            });
            waitingScreen.classList.add('hidden'); 
            // Hide Lobby lists during game
            lobbyListsContainer.classList.add('hidden');
            scoresSection.classList.remove('hidden');
            mobileTimerContainer.classList.remove('hidden'); 
        }

        function renderOverwriteUI(overwritesLeft) {
            overwriteUIDisplay.innerHTML = '';
            for (let i = 0; i < MAX_OVERWRITES; i++) {
                const box = document.createElement('div');
                box.className = 'overwrite-box';
                if (i < overwritesLeft) box.classList.add('bg-waiting-rainbow');
                else box.style.backgroundColor = '#d1d5db'; 
                overwriteUIDisplay.appendChild(box);
            }
            overwriteUIContainer.classList.remove('hidden');
        }

        function handleGameUpdate(gameData) {
            const myPlayerData = gameData.players[userId];
            if (myPlayerData && myPlayerData.isAI) {
                alert("You have been removed for missing the first turn.");
                if(localTimerInterval) clearInterval(localTimerInterval);
                if(unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
                resetToLobby();
                return; 
            }
            const myData = gameData.players[userId];
            if (myData) {
                myColor = myData.color;
                myOverwritesLeft = myData.overwrites;
                const cInfo = COLOR_MAP[myColor];
                myNicknameDisplay.textContent = myData.nickname;
                myNicknameMobile.textContent = myData.nickname;
                myNicknameMobile.style.color = cInfo.html_color;
                myColorDisplay.textContent = cInfo.label;
                renderOverwriteUI(myOverwritesLeft);
            } else {
                 myNicknameMobile.style.color = '#1a1a1a';
                 myColorDisplay.textContent = 'SPECTATOR';
                 overwriteUIContainer.classList.add('hidden');
            }

            if (gameData.turn < lastProcessedTurn) {
                lastProcessedTurn = 0;
                isAnimating = false;
                pendingGameEndData = null;
                document.getElementById('message-modal').classList.add('hidden');
            }
            if (gameData.status === 'finished') {
                if (localTimerInterval) clearInterval(localTimerInterval);
                updateTimerDisplay("0");
                if (gameData.turn > lastProcessedTurn) pendingGameEndData = gameData;
                else if (!isAnimating) showWinner(gameData.players);
            }

            if (gameData.turn > lastProcessedTurn) {
                isMoveCommitted = false;
                selectedCell = null;
                if (gameData.lastRoundEvents && gameData.turn > 1) { 
                    const events = JSON.parse(gameData.lastRoundEvents);
                    pendingBoardState = JSON.parse(gameData.board);
                    isAnimating = true;
                    triggerSequentialAnimations(events, gameData);
                } else {
                    currentBoardState = JSON.parse(gameData.board);
                    renderBoard(currentBoardState, gameData);
                }
                lastProcessedTurn = gameData.turn;
            } else if (!isAnimating) {
                currentBoardState = JSON.parse(gameData.board);
                renderBoard(currentBoardState, gameData);
            }
            renderScoreboard(gameData.players);
            if (gameData.status === 'playing') runClientTimer(gameData.turnDeadline, gameData);
        }

        function triggerSequentialAnimations(events, gameData) {
            if (!events || events.length === 0) {
                isAnimating = false;
                currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);
                if (pendingGameEndData) { setTimeout(() => { showWinner(pendingGameEndData.players); pendingGameEndData = null; }, 1000); }
                return;
            }
            let accumulatedDelay = 0;
            events.forEach((ev, index) => {
                const cellIdx = (ev.r * BOARD_SIZE) + ev.c;
                let duration = 1000;
                if(ev.type === 'flip') duration = 500;
                else if (ev.type === 'conflict') duration = (ev.colors.length * 1000) + 1000; 

                setTimeout(() => {
                    const cells = boardElement.querySelectorAll('.cell');
                    if (cells[cellIdx]) {
                        const cell = cells[cellIdx];
                        cell.style.animation = 'none'; cell.offsetHeight; cell.style.animation = null; 
                        if (ev.type === 'conflict') {
                            if(window.SoundManager) window.SoundManager.playConflict();
                            const sortOrder = ['R', 'Y', 'B'];
                            const colors = (ev.colors || []).sort((a, b) => sortOrder.indexOf(a) - sortOrder.indexOf(b));
                            colors.forEach((cCode, i) => {
                                setTimeout(() => {
                                    if(window.SoundManager) window.SoundManager.playGlass(); 
                                    cell.classList.remove('bg-white', 'bg-player-red', 'bg-player-yellow', 'bg-player-blue');
                                    cell.classList.add(COLOR_MAP[cCode].code);
                                    cell.style.animation = 'shine-pulse 1s forwards'; 
                                }, i * 1000);
                            });
                            setTimeout(() => { cell.style.animation = 'vanish-anim 1s forwards'; }, colors.length * 1000);
                        } else if (ev.type === 'success') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            cell.classList.remove('bg-white'); cell.classList.add(COLOR_MAP[ev.color].code); cell.style.animation = 'shine-pulse 1s forwards';
                        } else if (ev.type === 'flip') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            COLORS.forEach(c => cell.classList.remove(COLOR_MAP[c].code));
                            cell.classList.add(COLOR_MAP[ev.color].code);
                            cell.style.animation = 'flip-anim 0.5s forwards';
                        }
                    }
                }, accumulatedDelay);
                accumulatedDelay += duration;
            });
            setTimeout(() => {
                isAnimating = false;
                currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);
                if (pendingGameEndData) { setTimeout(() => { showWinner(pendingGameEndData.players); pendingGameEndData = null; }, 1000); }
            }, accumulatedDelay);
        }

        function updateTimerDisplay(text) {
            const displayText = isAnimating ? "0" : text;
            if(lastTimerValue !== displayText) {
                if(window.SoundManager && displayText !== "0" && displayText !== "--") window.SoundManager.playTick();
                lastTimerValue = displayText;
            }
            timerDisplay.textContent = displayText;
            document.getElementById('timer-display-mobile').textContent = displayText;
            if(displayText === "0") {
                 const cls = "font-mono font-bold leading-none text-gray-300";
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            } else {
                const val = parseInt(displayText);
                let colorClass = "text-black";
                if(val <= 2) colorClass = "text-red-600";
                const cls = `font-mono font-bold leading-none ${colorClass}`;
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            }
        }

        function runClientTimer(deadline, gameData) {
            if (localTimerInterval) clearInterval(localTimerInterval);
            const updateTimer = () => {
                if (isAnimating) { updateTimerDisplay("0"); return; }
                const now = Date.now();
                const totalDiff = deadline - now;
                const visualDiff = totalDiff - NETWORK_BUFFER_MS;
                if (visualDiff <= 500 && !isMoveCommitted && selectedCell) commitCurrentMove();
                let secondsLeft = Math.ceil(visualDiff / 1000);
                if (secondsLeft > 0) updateTimerDisplay(secondsLeft.toString());
                else {
                    updateTimerDisplay("0");
                    const isHost = userId === gameData.hostId;
                    const buffer = isHost ? 0 : 3000; 
                    if (!isResolving && now > deadline + buffer) resolveTurn(gameData);
                }
            };
            updateTimer();
            localTimerInterval = setInterval(updateTimer, 100);
        }

        async function commitCurrentMove() {
            if (!gameId || !userId || !selectedCell || isMoveCommitted) return;
            isMoveCommitted = true; 
            try { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), { [`players.${userId}.lastMove`]: selectedCell }); } 
            catch (e) { console.error("Failed to commit move:", e); }
        }

        async function resolveTurn(gameData) {
            if (isResolving) return;
            isResolving = true;
            let board = JSON.parse(gameData.board).map(r => [...r]);
            const players = gameData.players;
            let moves = [];
            for (const pid in players) {
                const p = players[pid]; 
                if (p.isAI) {
                    const aiMove = getStrategicAIMove(board, p, p.color);
                    if (aiMove) moves.push({ id: pid, color: p.color, r: aiMove.r, c: aiMove.c, isOverwrite: aiMove.isOverwrite });
                    else { const rand = getRandomMove(board); if(rand) moves.push({ id: pid, color: p.color, r: rand.r, c: rand.c, isOverwrite: false }); }
                } else if (p.lastMove) moves.push({ id: pid, color: p.color, r: p.lastMove.r, c: p.lastMove.c, isOverwrite: p.lastMove.isOverwrite });
            }
            const movesAtPos = {};
            moves.forEach(m => { const key = `${m.r},${m.c}`; if(!movesAtPos[key]) movesAtPos[key] = []; movesAtPos[key].push(m); });
            const roundEvents = [];
            let totalAnimTime = 0;
            for (const key in movesAtPos) {
                const cellMoves = movesAtPos[key];
                const [r, c] = key.split(',').map(Number);
                if (cellMoves.length > 1) {
                    const colors = cellMoves.map(m => m.color);
                    roundEvents.push({ r, c, type: 'conflict', colors: colors });
                    totalAnimTime += (colors.length * 1000) + 1000;
                    board[r][c] = ''; 
                }
            }
            const overwriteConsumers = new Set();
            const validMoves = moves.filter(m => {
                if (movesAtPos[`${m.r},${m.c}`].length > 1) return false; 
                const currentOwner = board[m.r][m.c];
                if (m.isOverwrite) {
                    if (currentOwner === '' || currentOwner === m.color) return false; 
                    if (players[m.id].overwrites <= 0) return false; 
                    return true;
                } else return currentOwner === '';
            });
            validMoves.forEach(m => {
                board[m.r][m.c] = m.color;
                roundEvents.push({ r: m.r, c: m.c, color: m.color, type: 'success' });
                totalAnimTime += 1000; 
                if(m.isOverwrite) overwriteConsumers.add(m.id);
                const flips = applyOthello(board, m.r, m.c, m.color);
                flips.forEach(f => {
                    board[f.r][f.c] = m.color; 
                    roundEvents.push({ r: f.r, c: f.c, color: m.color, type: 'flip' });
                    totalAnimTime += 500; 
                });
            });
            let newScores = {};
            let finalFilled = 0;
            for(let r=0; r<BOARD_SIZE; r++) { for(let c=0; c<BOARD_SIZE; c++) { const cell = board[r][c]; if(cell) { newScores[cell] = (newScores[cell] || 0) + 1; finalFilled++; } } }
            const updatedPlayers = {};
            for (const pid in players) {
                let p = players[pid];
                let newOverwrites = p.overwrites;
                if (overwriteConsumers.has(pid)) newOverwrites--;
                let isNowAI = p.isAI;
                let newNickname = p.nickname;
                if (gameData.turn === 1 && !p.isAI && !p.lastMove) { isNowAI = true; newNickname = `AI (AUTO)`; }
                updatedPlayers[pid] = { ...p, nickname: newNickname, isAI: isNowAI, lastMove: null, score: newScores[p.color] || 0, overwrites: newOverwrites };
            }
            const totalCells = BOARD_SIZE * BOARD_SIZE;
            const isEnd = finalFilled >= (totalCells - 1); 
            const nextDeadline = Date.now() + TURN_DURATION_MS + NETWORK_BUFFER_MS + totalAnimTime + 500;
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshSnap = await transaction.get(gameRef);
                    if (!freshSnap.exists()) throw "Game Over/Deleted";
                    const freshData = freshSnap.data();
                    if (freshData.turn > gameData.turn) return;
                    transaction.update(gameRef, {
                        board: JSON.stringify(board), players: updatedPlayers,
                        turn: gameData.turn + 1, turnDeadline: nextDeadline, status: isEnd ? 'finished' : 'playing',
                        lastRoundEvents: JSON.stringify(roundEvents)
                    });
                });
            } catch (e) { console.log("Turn resolution skipped or failed:", e); }
            selectedCell = null;
            isResolving = false;
        }

        function getStrategicAIMove(board, playerObj, color) {
            let possibleMoves = [];
            const emptyCells = [];
            const enemyCells = [];
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (board[r][c] === '') emptyCells.push({r, c});
                    else if (board[r][c] !== color) enemyCells.push({r, c});
                }
            }
            emptyCells.forEach(cell => {
                const flips = applyOthello(board, cell.r, cell.c, color);
                possibleMoves.push({ r: cell.r, c: cell.c, isOverwrite: false, flips: flips.length, score: (flips.length * 10) + 20 });
            });
            if (playerObj.overwrites > 0) {
                enemyCells.forEach(cell => {
                    const flips = applyOthello(board, cell.r, cell.c, color);
                    let allowed = false;
                    if (emptyCells.length <= 8) allowed = true;
                    else if (emptyCells.length <= 16) { if (flips.length >= 2) allowed = true; }
                    else { if (flips.length >= 3) allowed = true; }
                    if (allowed) {
                        const urgencyBonus = (25 - emptyCells.length) * 1.5; 
                        let score = (flips.length * 12) + urgencyBonus; 
                        possibleMoves.push({ r: cell.r, c: cell.c, isOverwrite: true, flips: flips.length, score: score });
                    }
                });
            }
            possibleMoves.sort((a, b) => b.score - a.score);
            if (possibleMoves.length > 0) {
                 const bestScore = possibleMoves[0].score;
                 const topMoves = possibleMoves.filter(m => m.score >= bestScore - 5);
                 return topMoves[Math.floor(Math.random() * topMoves.length)];
            }
            return null;
        }
        function getRandomMove(board) {
            let empties = [];
            for(let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) if(board[r][c] === '') empties.push({r,c});
            return empties.length ? empties[Math.floor(Math.random()*empties.length)] : null;
        }

        window.triggerRematch = async () => {
             document.getElementById('message-modal').classList.add('hidden');
             if (!gameId) return;
             const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
             const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
             const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
             try {
                 await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(gameRef);
                    if (!sfDoc.exists()) return;
                    const data = sfDoc.data();
                    const players = data.players;
                    const newPlayers = {};
                    for (const pid in players) {
                        newPlayers[pid] = { ...players[pid], score: 0, overwrites: MAX_OVERWRITES, lastMove: null };
                    }
                    transaction.update(gameRef, {
                        status: 'playing', turn: 1, turnDeadline: deadLine,
                        board: JSON.stringify(initialBoard), players: newPlayers, lastRoundEvents: "[]"
                    });
                 });
             } catch (e) { console.error("Rematch failed:", e); resetToLobby(); }
        };
        function setupPlayAgainListener() {
            const btn = document.getElementById('modal-play-again');
            if(btn) btn.onclick = () => window.triggerRematch();
        }
        setupPlayAgainListener();
    </script>
</body>
</html>