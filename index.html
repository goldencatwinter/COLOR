<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COLOR - Final Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
        
        body { 
            font-family: 'Montserrat', sans-serif; 
            background-color: #f0f0f0; 
            color: #1a1a1a;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Animations --- */
        @keyframes rainbowCycle {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes subtle-shine {
            0% { left: -100%; opacity: 0; }
            50% { opacity: 0.6; }
            100% { left: 100%; opacity: 0; }
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes shine-pulse {
            0% { 
                transform: scale(0.9); 
                filter: brightness(1.5);
                box-shadow: 0 0 0 0 rgba(255,255,255,0.7);
            }
            50% { 
                transform: scale(1.05); 
                filter: brightness(1.2);
                box-shadow: 0 0 20px 5px rgba(255,255,255,0.5);
            }
            100% { 
                transform: scale(1); 
                filter: brightness(1);
                box-shadow: 0 0 0 0 rgba(255,255,255,0);
            }
        }

        @keyframes vanish-anim {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }

        @keyframes flip-anim {
            0% { transform: perspective(400px) rotateY(0); }
            50% { transform: perspective(400px) rotateY(90deg); filter: brightness(2); }
            100% { transform: perspective(400px) rotateY(0); }
        }

        .title-rainbow {
            background: linear-gradient(to right, #ff0000, #ff8800, #ffff00, #008000, #0000ff, #4b0082, #ee82ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% auto;
            animation: rainbowCycle 10s linear infinite;
        }

        .bg-waiting-rainbow {
            background: linear-gradient(45deg, 
                #ff0000, #ffa500, #ffff00, #008000, #0000ff, #4b0082, #ee82ee, #ff0000
            );
            background-size: 400% 400%;
            animation: rainbowCycle 20s ease infinite;
        }

        .overwrite-box {
            width: 14px;
            height: 14px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            margin: 0 2px;
            transition: opacity 0.3s ease-out;
        }

        .bg-player-red { background-color: rgb(255, 0, 0); }
        .bg-player-yellow { background-color: rgb(255, 255, 0); }
        .bg-player-blue { background-color: rgb(0, 0, 255); }

        .text-player-red { color: rgb(255, 0, 0); }
        .text-player-yellow { color: rgb(210, 180, 0); } 
        .text-player-blue { color: rgb(0, 0, 255); }

        .breaker-shine {
            position: relative;
            overflow: hidden;
        }
        .breaker-shine::after {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 50%; height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.9), transparent);
            transform: skewX(-25deg);
            animation: subtle-shine 0.6s ease-out forwards;
            pointer-events: none;
        }

        .cell { transition: transform 0.1s ease-in-out; }
        .cell:hover:not(.occupied-immutable) { filter: brightness(0.9); cursor: pointer; }
        
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .queue-item { animation: slideIn 0.3s ease-out forwards; }

        .modal-content { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        /* Custom Checkbox */
        .friend-checkbox {
            appearance: none;
            background-color: #fff;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.15em;
            height: 1.15em;
            border: 2px solid currentColor;
            display: grid;
            place-content: center;
            cursor: pointer;
        }
        .friend-checkbox::before {
            content: "";
            width: 0.65em;
            height: 0.65em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em black;
            transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .friend-checkbox:checked::before {
            transform: scale(1);
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d4d4d4; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-2 md:p-8" onclick="SoundManager.init()">

    <div id="game-container" class="w-full max-w-7xl bg-white shadow-2xl flex flex-col lg:flex-row min-h-[700px] border border-gray-300">
        
        <div class="flex-1 flex flex-col p-6 md:p-10 relative">
            
            <div class="mb-8 flex justify-between items-end">
                <h1 class="text-6xl md:text-7xl font-black tracking-tighter title-rainbow">COLOR</h1>
                <div id="desktop-timer-container" class="text-right hidden md:block">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TIMER</p>
                    <p class="text-5xl font-mono font-bold leading-none" id="timer-display">--</p>
                </div>
            </div>

            <div id="my-info-mobile" class="flex md:hidden justify-between items-end border-b-2 border-black pb-4 mb-6">
                <div>
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">PLAYER</p>
                    <p class="text-lg font-black uppercase tracking-tight truncate" id="my-nickname-mobile" style="color:#1a1a1a;">-</p>
                </div>
                <div id="mobile-timer-container" class="text-right">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TURN TIMER</p>
                    <p class="text-4xl font-mono font-bold leading-none" id="timer-display-mobile">--</p>
                </div>
            </div>

            <div class="flex-1 flex items-center justify-center min-h-[400px] mb-8">
                <div id="game-board" class="relative grid grid-cols-5 gap-px bg-gray-300 p-px w-full max-w-[600px] aspect-square border-2 border-gray-300 shadow-lg">
                    
                    <div class="col-span-5 flex items-center justify-center h-full text-white text-xl font-bold tracking-widest uppercase bg-waiting-rainbow shadow-inner">
                        Waiting for match
                    </div>

                    <div id="message-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/30">
                        <div class="modal-content bg-white/20 border border-white/40 p-6 w-[80%] max-w-sm text-center backdrop-blur-md shadow-[0_8px_32px_0_rgba(31,38,135,0.37)] rounded-xl relative">
                            <button onclick="window.triggerRematch()" class="absolute top-2 right-3 text-white text-2xl font-bold p-1 leading-none hover:text-gray-300">&times;</button>
                            
                            <h3 id="modal-title" class="text-2xl font-black uppercase mb-3 tracking-tighter text-white drop-shadow-md">TITLE</h3>
                            <p id="modal-content" class="text-white mb-6 font-bold whitespace-pre-line leading-relaxed text-sm drop-shadow-sm">Content</p>
                            
                            <button id="modal-play-again" class="w-full bg-black hover:bg-gray-800 text-white border border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl mb-3">
                                PLAY AGAIN (SAME MEMBERS)
                            </button>
                        </div>
                    </div>

                </div>
            </div>
            
            <div class="flex flex-col items-center mt-auto w-full">
                
                <div id="overwrite-ui-container" class="w-full max-w-[600px] flex justify-end items-center px-2 mb-4 hidden">
                    <p class="text-xs font-bold text-gray-500 uppercase tracking-widest mr-2">OVERWRITE</p>
                    <div id="overwrite-ui-display" class="flex items-center">
                        </div>
                </div>

                <div class="flex flex-col gap-3 w-full max-w-md">
                    <div id="nickname-section" class="w-full">
                        <input type="text" id="nickname-input" placeholder="ENTER YOUR NAME" maxlength="10" 
                               class="w-full bg-gray-100 border-2 border-gray-200 p-4 font-bold text-center uppercase tracking-widest focus:outline-none focus:border-black transition-colors mb-3">
                        
                        <button id="join-queue-btn" disabled
                                class="w-full bg-black text-white hover:bg-gray-800 font-bold py-4 text-sm tracking-widest uppercase transition-colors disabled:opacity-30 disabled:cursor-not-allowed mb-2">
                            Find Match
                        </button>
                    </div>

                    <div id="game-buttons" class="hidden flex flex-col gap-2 w-full">
                         <button id="start-3p-quick-btn" 
                            class="hidden w-full bg-gradient-to-r from-red-600 via-yellow-500 to-blue-600 text-white font-black py-4 text-sm tracking-widest uppercase transition-all shadow-lg hover:scale-[1.02]">
                             Start 3P Quick Match
                         </button>

                         <button id="start-friends-btn" 
                            class="hidden w-full bg-black text-white border-2 border-black hover:bg-gray-800 font-bold py-3 text-sm tracking-widest uppercase transition-colors">
                             Start with Selected (3P)
                         </button>

                         <div class="flex gap-2 w-full">
                             <button id="force-ai-btn" 
                                     class="flex-1 bg-white text-black border-2 border-black hover:bg-black hover:text-white font-bold py-3 text-xs tracking-widest uppercase transition-colors">
                                 Solo AI
                             </button>
                             <button id="create-room-btn"
                                     class="flex-1 bg-blue-600 text-white border-2 border-blue-600 hover:bg-blue-700 font-bold py-3 text-xs tracking-widest uppercase transition-colors">
                                Create Open Room
                             </button>
                         </div>
                         <p class="text-[10px] text-gray-400 text-center font-bold uppercase mt-2">Wait for match or select options above</p>
                    </div>
                </div>
            </div>
            
            <span id="my-nickname-display" class="hidden"></span>
            <span id="my-color-display" class="hidden"></span>
        </div>

        <div class="w-full lg:w-96 bg-gray-50 border-t lg:border-t-0 lg:border-l border-gray-200 p-8 flex flex-col gap-4 h-full max-h-screen overflow-hidden">
            
            <div id="scores-section" class="hidden shrink-0">
                <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-2">SCORES</p>
                <ul id="score-list" class="space-y-2">
                    <li class="text-gray-300 text-xs uppercase tracking-widest py-2">Game not started</li>
                </ul>
            </div>

            <div id="lobby-panels" class="flex-1 flex flex-col gap-4 overflow-hidden min-h-0">
                
                <div id="queue-section" class="flex-1 flex flex-col min-h-0 bg-white border border-gray-200 p-4 shadow-sm">
                    <div class="flex justify-between items-center mb-2 border-b border-gray-100 pb-2 shrink-0">
                        <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">QUEUE</p>
                        <span id="queue-count" class="text-xs font-bold bg-black text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="queue-list" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        <p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No players waiting</p>
                    </div>
                </div>

                <div id="open-rooms-section" class="flex-1 flex flex-col min-h-0 bg-white border border-gray-200 p-4 shadow-sm">
                    <div class="flex justify-between items-center mb-2 border-b border-gray-100 pb-2 shrink-0">
                        <p class="text-[10px] font-bold text-blue-600 uppercase tracking-widest">OPEN ROOMS</p>
                        <span id="open-rooms-count" class="text-xs font-bold bg-blue-600 text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="open-rooms-list" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        <p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No Open Rooms</p>
                    </div>
                </div>

                </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, 
            query, where, getDocs, runTransaction, serverTimestamp, orderBy, limit 
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Sound Manager ---
        window.SoundManager = {
            ctx: null,
            init: function() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.playAmbient();
                
                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        if (queueDocId && !gameId) {
                            console.log("Background detected: Leaving queue.");
                            await leaveQueue(); 
                            resetLocalStateAndUI(); 
                        }
                    }
                });

                window.addEventListener('beforeunload', () => {
                    if (queueDocId && !gameId) {
                        leaveQueue(); 
                    }
                });
            },
            playAmbient: function() {
                const t = this.ctx.currentTime;
                const gain = this.ctx.createGain();
                gain.connect(this.ctx.destination);
                
                const freqs = [261.63, 329.63, 392.00, 493.88]; 
                
                freqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                    osc.frequency.value = f;
                    
                    const oscGain = this.ctx.createGain();
                    oscGain.gain.value = 0.03; 
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.1 + (i * 0.05);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.01;
                    lfo.connect(lfoGain);
                    lfoGain.connect(oscGain.gain);
                    lfo.start();

                    osc.connect(oscGain);
                    oscGain.connect(gain);
                    osc.start();
                });

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.5, t + 5); 
            },
            playGlass: function() { 
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1500, t); 
                osc.frequency.exponentialRampToValueAtTime(1500, t + 1); 
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.4, t + 0.01); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); 

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 1.5);
                
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(3000, t);
                
                gain2.gain.setValueAtTime(0, t);
                gain2.gain.linearRampToValueAtTime(0.05, t + 0.01);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
                
                gain2.connect(this.ctx.destination);
                osc2.start(t);
                osc2.stop(t + 1.0);
            },
            playConflict: function() { 
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.5);
            },
            playTick: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'square';
                filter.type = 'highpass';
                filter.frequency.value = 2000;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                osc.frequency.setValueAtTime(800, t);
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

                osc.start();
                osc.stop(t + 0.05);
            }
        };

        // --- Config ---
        const BOARD_SIZE = 5;
        const TURN_DURATION_MS = 5000; 
        const FIRST_TURN_DURATION_MS = 10000; 
        const NETWORK_BUFFER_MS = 1000;
        const MAX_OVERWRITES = 3; 
        
        const COLORS = ['R', 'Y', 'B']; 
        
        const COLOR_MAP = {
            'R': { code: 'bg-player-red', text: 'text-player-red', label: 'RED', html_color: 'rgb(255, 0, 0)' },
            'Y': { code: 'bg-player-yellow', text: 'text-player-yellow', label: 'YELLOW', html_color: 'rgb(210, 180, 0)' },
            'B': { code: 'bg-player-blue', text: 'text-player-blue', label: 'BLUE', html_color: 'rgb(0, 0, 255)' },
        };
        
        const firebaseConfig = {
            apiKey: "AIzaSyA1DEzZvw6_63cLUk_YeWYRInZ0drIzd5Q",
            authDomain: "color-a6d38.firebaseapp.com",
            projectId: "color-a6d38",
            storageBucket: "color-a6d38.firebasestorage.app",
            messagingSenderId: "761735384766",
            appId: "1:761735384766:web:cc52566ccafac650a558ef"
        };
        
        const appId = 'Color-Game-V7-Conflict';

        let app, db, auth, userId;
        let myNickname = "";
        let queueDocId = null;
        let gameId = null;
        let myColor = null;
        let myOverwritesLeft = MAX_OVERWRITES;
        let currentQueueDocs = []; 
        let lastProcessedTurn = 0; 
        let isAnimating = false; 
        let pendingBoardState = null; 
        let pendingGameEndData = null; 
        let selectedFriendIds = new Set(); 
        
        let unsubscribeQueue = null;
        let unsubscribeGame = null;
        let unsubscribeMyTicket = null;
        let unsubscribeOpenRooms = null;

        const nicknameInput = document.getElementById('nickname-input');
        const nicknameSection = document.getElementById('nickname-section');
        const joinBtn = document.getElementById('join-queue-btn');
        const createRoomBtn = document.getElementById('create-room-btn');
        const gameButtonsDiv = document.getElementById('game-buttons');
        const aiBtn = document.getElementById('force-ai-btn');
        
        const start3pBtn = document.getElementById('start-3p-quick-btn');
        const startFriendsBtn = document.getElementById('start-friends-btn');
        
        const queueListEl = document.getElementById('queue-list');
        const queueCountEl = document.getElementById('queue-count');
        const boardElement = document.getElementById('game-board');
        const timerDisplay = document.getElementById('timer-display');
        const timerDisplayMobile = document.getElementById('timer-display-mobile');
        
        const scoresSection = document.getElementById('scores-section');
        const lobbyPanels = document.getElementById('lobby-panels');
        const scoreList = document.getElementById('score-list');
        
        const desktopTimerContainer = document.getElementById('desktop-timer-container');
        const mobileTimerContainer = document.getElementById('mobile-timer-container');
        
        const myNicknameDisplay = document.getElementById('my-nickname-display');
        const myColorDisplay = document.getElementById('my-color-display'); 
        const myNicknameMobile = document.getElementById('my-nickname-mobile'); 

        const overwriteUIDisplay = document.getElementById('overwrite-ui-display');
        const overwriteUIContainer = document.getElementById('overwrite-ui-container');

        let currentBoardState = [];
        let selectedCell = null; 
        let isResolving = false;
        let localTimerInterval = null;
        let lastTimerValue = ""; 

        let lastGameMode = null; 
        let isMoveCommitted = false; 

        // --- Strict Queue Watchdog ---
        let queueKickTimer = null;
        const STRICT_QUEUE_TIMEOUT = 30000; 

        function startQueueWatchdog() {
            resetQueueWatchdog();
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.addEventListener(evt, resetQueueWatchdog);
            });
        }

        function stopQueueWatchdog() {
            if (queueKickTimer) clearTimeout(queueKickTimer);
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.removeEventListener(evt, resetQueueWatchdog);
            });
        }

        function resetQueueWatchdog() {
            if (queueKickTimer) clearTimeout(queueKickTimer);
            
            if (queueDocId && !gameId) {
                queueKickTimer = setTimeout(async () => {
                    console.log("Strict 30s Inactivity in Queue: Kicking user.");
                    await leaveQueue();
                    resetLocalStateAndUI();
                    // No Alert, just reset
                }, STRICT_QUEUE_TIMEOUT);
            }
        }

        async function init() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            try {
                const credential = await signInAnonymously(auth);
                userId = credential.user.uid; 
                console.log("Logged in as:", userId);
            } catch (error) {
                console.error("Auth failed:", error);
            }
            
            onAuthStateChanged(auth, (user) => {
                if (user && !userId) userId = user.uid;
            });

            mobileTimerContainer.classList.add('hidden');
            overwriteUIContainer.classList.add('hidden');
            
            watchQueueList();
            watchOpenRooms();
        }
        window.onload = init;

        nicknameInput.addEventListener('input', (e) => {
            joinBtn.disabled = e.target.value.trim().length === 0;
        });

        // --- Create Room Button Logic (Called from Screen 2) ---
        createRoomBtn.addEventListener('click', async () => {
            // Already in queue, so myNickname is set
            if(window.SoundManager) window.SoundManager.init();
            
            const roomName = prompt("방 제목을 입력하세요 (Enter Room Name):");
            if (!roomName) return;

            // Must leave queue first to become host
            await leaveQueue();
            
            await createPublicRoom(roomName);
        });

        // --- Join Queue (Auto) Button ---
        async function performJoinQueue() {
            if (!userId) {
                if (auth.currentUser) {
                    userId = auth.currentUser.uid;
                } else {
                    alert("Network initializing... Please try again in a moment.");
                    return;
                }
            }
            
            if(window.SoundManager) {
                window.SoundManager.init();
            }

            nicknameSection.classList.add('hidden'); 
            gameButtonsDiv.classList.remove('hidden'); 
            
            myNicknameDisplay.textContent = myNickname;
            myNicknameMobile.textContent = myNickname; 

            joinBtn.textContent = "SEARCHING...";
            joinBtn.disabled = true;
            nicknameInput.disabled = true;

            selectedFriendIds.clear(); // Reset selections on join

            try {
                const queueRef = collection(db, 'artifacts', appId, 'public', 'data', 'queue');
                const ticketRef = doc(queueRef, userId);
                await setDoc(ticketRef, { 
                    userId: userId, 
                    nickname: myNickname,
                    joinedAt: serverTimestamp(), 
                    matchId: null 
                });
                queueDocId = userId;
                
                startQueueWatchdog();
                watchMyTicket(ticketRef);
            } catch (e) {
                console.error(e);
                alert("Connection Error. Please refresh.");
                resetLocalStateAndUI();
            }
        }

        joinBtn.addEventListener('click', async () => {
            const val = nicknameInput.value.trim();
            if(!val) return;
            myNickname = val.toUpperCase().slice(0, 10);
            await performJoinQueue();
        });

        function watchMyTicket(docRef) {
            unsubscribeMyTicket = onSnapshot(docRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (queueDocId) {
                        resetLocalStateAndUI();
                    }
                    return;
                }
                const data = docSnap.data();
                if (data.matchId) {
                    lastGameMode = 'PVP'; 
                    enterGame(data.matchId);
                }
            });
        }

        function watchQueueList() {
            if (unsubscribeQueue) return; 

            const queueRef = collection(db, 'artifacts', appId, 'public', 'data', 'queue');
            const q = query(queueRef, orderBy('joinedAt', 'asc'), limit(12));
            unsubscribeQueue = onSnapshot(q, (snapshot) => {
                const docs = snapshot.docs;
                currentQueueDocs = docs;
                renderQueueList(docs);
                
                // --- Logic Update: Button Visibility in Lobby ---
                if (queueDocId) {
                    // Update Button Visibility based on counts
                    
                    // 1. Quick Start (3 Players)
                    if (docs.length >= 3) {
                        start3pBtn.classList.remove('hidden');
                        start3pBtn.textContent = `START 3P GAME (${docs.length} WAITING)`;
                    } else {
                        start3pBtn.classList.add('hidden');
                    }

                    // 2. Friends Start
                    if (selectedFriendIds.size === 2) {
                        startFriendsBtn.classList.remove('hidden');
                    } else {
                        startFriendsBtn.classList.add('hidden');
                    }

                    // 3. AI & Create Room are static (always visible in lobby)
                }
            });
        }

        async function createMatchedGame(usersDocs) { await initGameWithPlayers(usersDocs); }

        start3pBtn.addEventListener('click', async () => {
             if(window.SoundManager) window.SoundManager.init();
             if (!queueDocId || currentQueueDocs.length < 3) return;
             // Pick top 3 players
             const top3 = currentQueueDocs.slice(0, 3);
             await initGameWithPlayers(top3);
        });

        startFriendsBtn.addEventListener('click', async () => {
             if(window.SoundManager) window.SoundManager.init();
             if (!queueDocId || selectedFriendIds.size !== 2) return;
             
             // Filter docs to match selected IDs + Self
             const selectedDocs = currentQueueDocs.filter(d => 
                 d.id === userId || selectedFriendIds.has(d.id)
             );

             if (selectedDocs.length !== 3) {
                 alert("Selected players might have left the queue.");
                 return;
             }
             
             await initGameWithPlayers(selectedDocs);
        });

        aiBtn.addEventListener('click', async () => {
            await startSoloAiGame();
        });

        async function initGameWithPlayers(usersDocs, fillAI = false) {
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const newGameRef = doc(gamesRef);
            const newGameId = newGameRef.id;
            const playersData = {};
            const playerOrder = [];
            
            usersDocs.forEach((d, idx) => {
                const uid = d.data().userId;
                const nick = d.data().nickname || "Unknown";
                playersData[uid] = { 
                    nickname: nick, 
                    color: COLORS[idx], 
                    isAI: false, 
                    score: 0, 
                    overwrites: MAX_OVERWRITES, 
                    lastMove: null
                };
                playerOrder.push(uid);
            });

            if (fillAI && usersDocs.length < 3) {
                const aiCount = 3 - usersDocs.length;
                for(let i=0; i<aiCount; i++) {
                    const colorIndex = usersDocs.length + i;
                    const aiId = `AI_CPU_${i+1}`;
                    playersData[aiId] = { 
                        nickname: "AI BOT", 
                        color: COLORS[colorIndex], 
                        isAI: true, 
                        score: 0, 
                        overwrites: MAX_OVERWRITES, 
                        lastMove: null
                    };
                    playerOrder.push(aiId);
                }
                lastGameMode = 'PVP_AI'; 
            } else {
                lastGameMode = 'PVP';
            }

            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;

            await runTransaction(db, async (transaction) => {
                transaction.set(newGameRef, {
                    status: 'playing', turn: 1, turnDeadline: deadLine,
                    board: JSON.stringify(initialBoard), players: playersData,
                    playerOrder: playerOrder, hostId: userId, createdAt: serverTimestamp(),
                    lastRoundEvents: "[]"
                });
                for (const d of usersDocs) {
                    const qRef = doc(db, 'artifacts', appId, 'public', 'data', 'queue', d.id);
                    transaction.update(qRef, { matchId: newGameId });
                }
            });
        }

        async function startSoloAiGame() {
            if(window.SoundManager) window.SoundManager.init();
            
            if (queueDocId) await leaveQueue();

            lastGameMode = 'AI';
            
            const newGameRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'games'));
            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const playersData = {
                [userId]: { nickname: myNickname, color: 'R', isAI: false, score: 0, overwrites: MAX_OVERWRITES, lastMove: null },
                'AI_Y': { nickname: "AI YELLOW", color: 'Y', isAI: true, score: 0, overwrites: MAX_OVERWRITES, lastMove: null }, 
                'AI_B': { nickname: "AI BLUE", color: 'B', isAI: true, score: 0, overwrites: MAX_OVERWRITES, lastMove: null } 
            };
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
            await setDoc(newGameRef, {
                status: 'playing', turn: 1, turnDeadline: deadLine,
                board: JSON.stringify(initialBoard), players: playersData,
                playerOrder: [userId, 'AI_Y', 'AI_B'], hostId: userId, createdAt: serverTimestamp(),
                lastRoundEvents: "[]"
            });
            enterGame(newGameRef.id);
        }

        async function leaveQueue() {
            stopQueueWatchdog();

            if (unsubscribeMyTicket) { unsubscribeMyTicket(); unsubscribeMyTicket = null; }
            if (queueDocId) {
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', queueDocId));
                queueDocId = null;
            }
        }

        function resetLocalStateAndUI() {
            stopQueueWatchdog();
            
            if (localTimerInterval) clearInterval(localTimerInterval);
            
            if (unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
            if (unsubscribeMyTicket) { unsubscribeMyTicket(); unsubscribeMyTicket = null; }

            // Keep global listeners active
            watchQueueList(); 
            watchOpenRooms();

            queueDocId = null;
            gameId = null;
            myColor = null;
            myOverwritesLeft = MAX_OVERWRITES;
            lastProcessedTurn = 0;
            isAnimating = false;
            pendingBoardState = null;
            pendingGameEndData = null;
            selectedCell = null;
            isResolving = false;
            lastTimerValue = "";
            isMoveCommitted = false; 
            myNickname = ""; 
            
            selectedFriendIds.clear(); 

            // Restore UI to entrance state
            nicknameSection.classList.remove('hidden');
            gameButtonsDiv.classList.add('hidden');
            
            nicknameInput.disabled = false;
            nicknameInput.value = "";
            nicknameInput.focus();
            
            joinBtn.textContent = "Find Match";
            joinBtn.disabled = true;
            
            // Hide specific buttons
            start3pBtn.classList.add('hidden');
            startFriendsBtn.classList.add('hidden');
            
            // Note: AI and CreateRoom are part of gameButtonsDiv, which is hidden, so we are good.

            myNicknameDisplay.textContent = ''; 
            myNicknameMobile.textContent = '-';
            myNicknameMobile.style.color = '#1a1a1a';
            
            myColorDisplay.textContent = 'SPECTATOR';

            overwriteUIDisplay.innerHTML = '';
            overwriteUIContainer.classList.add('hidden');
            
            scoresSection.classList.add('hidden');
            lobbyPanels.classList.remove('hidden');
            
            mobileTimerContainer.classList.add('hidden');

            updateTimerDisplay("--");

            scoreList.innerHTML = '<li class="text-gray-300 text-xs uppercase tracking-widest py-2">Game not started</li>';
            
            boardElement.innerHTML = `<div class="col-span-5 flex items-center justify-center h-full text-white text-xl font-bold tracking-widest uppercase bg-waiting-rainbow shadow-inner">
                        Waiting for match
                    </div>
                    <div id="message-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/30">
                        <div class="modal-content bg-white/20 border border-white/40 p-6 w-[80%] max-w-sm text-center backdrop-blur-md shadow-[0_8px_32px_0_rgba(31,38,135,0.37)] rounded-xl relative">
                            <button onclick="window.triggerRematch()" class="absolute top-2 right-3 text-white text-2xl font-bold p-1 leading-none hover:text-gray-300">&times;</button>
                            <h3 id="modal-title" class="text-2xl font-black uppercase mb-3 tracking-tighter text-white drop-shadow-md">TITLE</h3>
                            <p id="modal-content" class="text-white mb-6 font-bold whitespace-pre-line leading-relaxed text-sm drop-shadow-sm">Content</p>
                            
                            <button id="modal-play-again" class="w-full bg-black hover:bg-gray-800 text-white border border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl mb-3">
                                PLAY AGAIN (SAME MEMBERS)
                            </button>
                        </div>
                    </div>`;
             
             setupPlayAgainListener();
        }

        async function enterGame(id) {
            stopQueueWatchdog();
            
            gameId = id;
            await leaveQueue();

            if (unsubscribeQueue) { unsubscribeQueue(); unsubscribeQueue = null; }
            
            nicknameSection.classList.add('hidden');
            gameButtonsDiv.classList.remove('hidden');
            
            // Hide queue buttons
            start3pBtn.classList.add('hidden');
            startFriendsBtn.classList.add('hidden');
            // Hide lobby buttons (Solo/Create)
            gameButtonsDiv.classList.add('hidden');

            
            unsubscribeGame = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (docSnap) => {
                if(!docSnap.exists()) {
                    if(localTimerInterval) clearInterval(localTimerInterval);
                    resetLocalStateAndUI();
                    return;
                }
                handleGameUpdate(docSnap.data());
            });
            
            lobbyPanels.classList.add('hidden');
            scoresSection.classList.remove('hidden');
            mobileTimerContainer.classList.remove('hidden'); 
        }

        function renderOverwriteUI(overwritesLeft) {
            overwriteUIDisplay.innerHTML = '';
            for (let i = 0; i < MAX_OVERWRITES; i++) {
                const box = document.createElement('div');
                box.className = 'overwrite-box';
                if (i < overwritesLeft) {
                    box.classList.add('bg-waiting-rainbow');
                } else {
                    box.style.backgroundColor = '#d1d5db'; 
                }
                overwriteUIDisplay.appendChild(box);
            }
            overwriteUIContainer.classList.remove('hidden');
        }

        function handleGameUpdate(gameData) {
            // Handle "Waiting" status for lobby hosts
            if (gameData.status === 'waiting') {
                const waitingEl = boardElement.querySelector('.col-span-5');
                if (waitingEl) {
                    const pCount = Object.keys(gameData.players).length;
                    const rName = gameData.roomName || 'Room';
                    waitingEl.innerHTML = `
                        <div class="flex flex-col items-center justify-center text-center">
                            <h2 class="text-2xl font-black uppercase mb-2 text-yellow-300 drop-shadow-md">${rName}</h2>
                            <p class="text-sm font-bold text-white/80 mb-4">Waiting for challengers... (${pCount}/3)</p>
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                        </div>`;
                }
                
                // Update my info even in lobby
                const myData = gameData.players[userId];
                if(myData) {
                     myNicknameDisplay.textContent = myData.nickname;
                     myNicknameMobile.textContent = myData.nickname;
                     myColor = myData.color;
                     const cInfo = COLOR_MAP[myColor];
                     myNicknameMobile.style.color = cInfo.html_color;
                     myColorDisplay.textContent = cInfo.label;
                }
                
                renderScoreboard(gameData.players);
                return;
            }

            const myPlayerData = gameData.players[userId];
            if (myPlayerData && myPlayerData.isAI) {
                // If I was turned into AI, I was kicked
                if(localTimerInterval) clearInterval(localTimerInterval);
                if(unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
                resetLocalStateAndUI();
                return; 
            }

            lobbyPanels.classList.add('hidden');
            scoresSection.classList.remove('hidden');
            mobileTimerContainer.classList.remove('hidden');

            // --- DETECT RESET (REMATCH) ---
            if (gameData.turn < lastProcessedTurn) {
                lastProcessedTurn = 0;
                isAnimating = false;
                pendingGameEndData = null;
                document.getElementById('message-modal').classList.add('hidden');
            }

            const myData = gameData.players[userId];
            if (myData) {
                myColor = myData.color;
                myOverwritesLeft = myData.overwrites;
                const cInfo = COLOR_MAP[myColor];
                
                myNicknameDisplay.textContent = myData.nickname;
                myNicknameMobile.textContent = myData.nickname;
                myNicknameMobile.style.color = cInfo.html_color;
                
                myColorDisplay.textContent = cInfo.label;
                renderOverwriteUI(myOverwritesLeft);
            } else {
                 myNicknameMobile.style.color = '#1a1a1a';
                 myColorDisplay.textContent = 'SPECTATOR';
                 overwriteUIContainer.classList.add('hidden');
            }
            
            if (gameData.status === 'finished') {
                if (localTimerInterval) clearInterval(localTimerInterval);
                updateTimerDisplay("0");
                
                if (gameData.turn > lastProcessedTurn) {
                    pendingGameEndData = gameData;
                } else if (!isAnimating) {
                    showWinner(gameData.players);
                }
            }

            // --- Detect New Turn ---
            if (gameData.turn > lastProcessedTurn) {
                isMoveCommitted = false;
                selectedCell = null;

                if (gameData.lastRoundEvents && gameData.turn > 1) { 
                    const events = JSON.parse(gameData.lastRoundEvents);
                    pendingBoardState = JSON.parse(gameData.board);
                    isAnimating = true;
                    triggerSequentialAnimations(events, gameData);
                } else {
                    currentBoardState = JSON.parse(gameData.board);
                    renderBoard(currentBoardState, gameData);
                }
                lastProcessedTurn = gameData.turn;
            } else if (!isAnimating) {
                currentBoardState = JSON.parse(gameData.board);
                renderBoard(currentBoardState, gameData);
            }

            renderScoreboard(gameData.players);

            if (gameData.status === 'playing') {
                runClientTimer(gameData.turnDeadline, gameData);
            }
        }

        function triggerSequentialAnimations(events, gameData) {
            if (!events || events.length === 0) {
                isAnimating = false;
                currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);
                
                if (pendingGameEndData) {
                    setTimeout(() => {
                        showWinner(pendingGameEndData.players);
                        pendingGameEndData = null;
                    }, 1000); 
                }
                return;
            }
            
            let accumulatedDelay = 0;

            events.forEach((ev, index) => {
                const cellIdx = (ev.r * BOARD_SIZE) + ev.c;
                let duration = 1000;
                if(ev.type === 'flip') duration = 500;
                else if (ev.type === 'conflict') {
                    duration = (ev.colors.length * 1000) + 1000; 
                }

                setTimeout(() => {
                    const cells = boardElement.querySelectorAll('.cell');
                    if (cells[cellIdx]) {
                        const cell = cells[cellIdx];
                        cell.style.animation = 'none';
                        cell.offsetHeight; 
                        cell.style.animation = null; 

                        if (ev.type === 'conflict') {
                            if(window.SoundManager) window.SoundManager.playConflict();
                            const sortOrder = ['R', 'Y', 'B'];
                            const colors = (ev.colors || []).sort((a, b) => sortOrder.indexOf(a) - sortOrder.indexOf(b));
                            
                            colors.forEach((cCode, i) => {
                                setTimeout(() => {
                                    if(window.SoundManager) window.SoundManager.playGlass(); 
                                    cell.classList.remove('bg-white', 'bg-player-red', 'bg-player-yellow', 'bg-player-blue');
                                    cell.classList.add(COLOR_MAP[cCode].code);
                                    cell.style.animation = 'shine-pulse 1s forwards'; 
                                }, i * 1000);
                            });

                            setTimeout(() => {
                                cell.style.animation = 'vanish-anim 1s forwards';
                            }, colors.length * 1000);

                        } else if (ev.type === 'success') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            cell.classList.remove('bg-white');
                            cell.classList.add(COLOR_MAP[ev.color].code);
                            cell.style.animation = 'shine-pulse 1s forwards';
                        } else if (ev.type === 'flip') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            COLORS.forEach(c => cell.classList.remove(COLOR_MAP[c].code));
                            cell.classList.add(COLOR_MAP[ev.color].code);
                            cell.style.animation = 'flip-anim 0.5s forwards';
                        }
                    }
                }, accumulatedDelay);

                accumulatedDelay += duration;
            });

            setTimeout(() => {
                isAnimating = false;
                currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);

                if (pendingGameEndData) {
                    setTimeout(() => {
                        showWinner(pendingGameEndData.players);
                        pendingGameEndData = null;
                    }, 1000); 
                }
            }, accumulatedDelay);
        }

        function updateTimerDisplay(text) {
            const displayText = isAnimating ? "0" : text;
            if(lastTimerValue !== displayText) {
                if(window.SoundManager && displayText !== "0" && displayText !== "--") {
                    window.SoundManager.playTick();
                }
                lastTimerValue = displayText;
            }
            timerDisplay.textContent = displayText;
            document.getElementById('timer-display-mobile').textContent = displayText;
            
            if(displayText === "0") {
                 const cls = "font-mono font-bold leading-none text-gray-300";
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            } else {
                const val = parseInt(displayText);
                let colorClass = "text-black";
                if(val <= 2) colorClass = "text-red-600";
                const cls = `font-mono font-bold leading-none ${colorClass}`;
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            }
        }

        function runClientTimer(deadline, gameData) {
            if (localTimerInterval) clearInterval(localTimerInterval);
            
            const updateTimer = () => {
                if (isAnimating) {
                    updateTimerDisplay("0");
                    return;
                }
                
                const now = Date.now();
                const totalDiff = deadline - now;
                const visualDiff = totalDiff - NETWORK_BUFFER_MS;
                
                if (visualDiff <= 500 && !isMoveCommitted && selectedCell) {
                    commitCurrentMove();
                }

                let secondsLeft = Math.ceil(visualDiff / 1000);

                if (secondsLeft > 0) {
                    updateTimerDisplay(secondsLeft.toString());
                } else {
                    updateTimerDisplay("0");
                    
                    const isHost = userId === gameData.hostId;
                    const buffer = isHost ? 0 : 3000; 

                    if (!isResolving && now > deadline + buffer) {
                        resolveTurn(gameData);
                    }
                }
            };
            
            updateTimer();
            localTimerInterval = setInterval(updateTimer, 100);
        }

        async function commitCurrentMove() {
            if (!gameId || !userId || !selectedCell || isMoveCommitted) return;

            isMoveCommitted = true; 
            
            try {
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    [`players.${userId}.lastMove`]: selectedCell
                });
                console.log("Move committed to DB:", selectedCell);
            } catch (e) {
                console.error("Failed to commit move:", e);
            }
        }

        function getStrategicAIMove(board, playerObj, color) {
            let possibleMoves = [];
            const emptyCells = [];
            const enemyCells = [];
            
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (board[r][c] === '') emptyCells.push({r, c});
                    else if (board[r][c] !== color) enemyCells.push({r, c});
                }
            }

            emptyCells.forEach(cell => {
                const flips = applyOthello(board, cell.r, cell.c, color);
                possibleMoves.push({
                    r: cell.r, c: cell.c, isOverwrite: false,
                    flips: flips.length,
                    score: (flips.length * 10) + 20 
                });
            });

            if (playerObj.overwrites > 0) {
                enemyCells.forEach(cell => {
                    const flips = applyOthello(board, cell.r, cell.c, color);
                    let allowed = false;
                    
                    if (emptyCells.length <= 8) {
                        allowed = true;
                    } 
                    else if (emptyCells.length <= 16) {
                        if (flips.length >= 2) allowed = true;
                    }
                    else {
                        if (flips.length >= 3) allowed = true;
                    }

                    if (allowed) {
                        const urgencyBonus = (25 - emptyCells.length) * 1.5; 
                        let score = (flips.length * 12) + urgencyBonus; 
                        
                        possibleMoves.push({
                            r: cell.r, c: cell.c, isOverwrite: true,
                            flips: flips.length,
                            score: score
                        });
                    }
                });
            }

            possibleMoves.sort((a, b) => b.score - a.score);
            
            if (possibleMoves.length > 0) {
                 const bestScore = possibleMoves[0].score;
                 const topMoves = possibleMoves.filter(m => m.score >= bestScore - 5);
                 return topMoves[Math.floor(Math.random() * topMoves.length)];
            }
            
            return null;
        }

        async function resolveTurn(gameData) {
            if (isResolving) return;
            isResolving = true;
            let board = JSON.parse(gameData.board).map(r => [...r]);
            const players = gameData.players;
            let moves = [];
            
            for (const pid in players) {
                const p = players[pid]; 

                if (p.isAI) {
                    const aiMove = getStrategicAIMove(board, p, p.color);
                    if (aiMove) {
                         moves.push({ id: pid, color: p.color, r: aiMove.r, c: aiMove.c, isOverwrite: aiMove.isOverwrite });
                    } else {
                        const rand = getRandomMove(board);
                        if(rand) moves.push({ id: pid, color: p.color, r: rand.r, c: rand.c, isOverwrite: false });
                    }
                } else {
                    if (p.lastMove) {
                        moves.push({ id: pid, color: p.color, r: p.lastMove.r, c: p.lastMove.c, isOverwrite: p.lastMove.isOverwrite });
                    } else {
                        if (gameData.turn === 1) {
                            console.log(`Player ${pid} missed FIRST turn. Kicking...`);
                        } else {
                            console.log(`Player ${pid} missed turn ${gameData.turn}. Skipping turn.`);
                        }
                    }
                }
            }

            const movesAtPos = {};
            moves.forEach(m => {
                const key = `${m.r},${m.c}`;
                if(!movesAtPos[key]) movesAtPos[key] = [];
                movesAtPos[key].push(m);
            });
            
            const roundEvents = [];
            let totalAnimTime = 0;

            for (const key in movesAtPos) {
                const cellMoves = movesAtPos[key];
                const [r, c] = key.split(',').map(Number);

                if (cellMoves.length > 1) {
                    const colors = cellMoves.map(m => m.color);
                    roundEvents.push({ r, c, type: 'conflict', colors: colors });
                    totalAnimTime += (colors.length * 1000) + 1000;
                    board[r][c] = ''; 
                }
            }

            const overwriteConsumers = new Set();
            
            const validMoves = moves.filter(m => {
                if (movesAtPos[`${m.r},${m.c}`].length > 1) return false; 
                const currentOwner = board[m.r][m.c];
                if (m.isOverwrite) {
                    if (currentOwner === '' || currentOwner === m.color) return false; 
                    if (players[m.id].overwrites <= 0) return false; 
                    return true;
                } else {
                    return currentOwner === '';
                }
            });

            validMoves.forEach(m => {
                board[m.r][m.c] = m.color;
                roundEvents.push({ r: m.r, c: m.c, color: m.color, type: 'success' });
                totalAnimTime += 1000; 

                if(m.isOverwrite) overwriteConsumers.add(m.id);
                
                const flips = applyOthello(board, m.r, m.c, m.color);
                flips.forEach(f => {
                    board[f.r][f.c] = m.color; 
                    roundEvents.push({ r: f.r, c: f.c, color: m.color, type: 'flip' });
                    totalAnimTime += 500; 
                });
            });

            let newScores = {};
            let finalFilled = 0;
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const cell = board[r][c];
                    if(cell) { newScores[cell] = (newScores[cell] || 0) + 1; finalFilled++; }
                }
            }

            const updatedPlayers = {};
            for (const pid in players) {
                let p = players[pid];
                let newOverwrites = p.overwrites;
                if (overwriteConsumers.has(pid)) newOverwrites--;
                
                let isNowAI = p.isAI;
                let newNickname = p.nickname;
                
                if (gameData.turn === 1 && !p.isAI && !p.lastMove) {
                    isNowAI = true; 
                    newNickname = `AI (AUTO)`; 
                }

                updatedPlayers[pid] = { 
                    ...p, 
                    nickname: newNickname,
                    isAI: isNowAI,
                    lastMove: null, 
                    score: newScores[p.color] || 0, 
                    overwrites: newOverwrites
                };
            }

            const totalCells = BOARD_SIZE * BOARD_SIZE;
            const isEnd = finalFilled >= (totalCells - 1); 
            
            const nextDeadline = Date.now() + TURN_DURATION_MS + NETWORK_BUFFER_MS + totalAnimTime + 500;

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshSnap = await transaction.get(gameRef);
                    if (!freshSnap.exists()) throw "Game Over/Deleted";
                    
                    const freshData = freshSnap.data();
                    if (freshData.turn > gameData.turn) return;

                    transaction.update(gameRef, {
                        board: JSON.stringify(board), players: updatedPlayers,
                        turn: gameData.turn + 1, turnDeadline: nextDeadline, status: isEnd ? 'finished' : 'playing',
                        lastRoundEvents: JSON.stringify(roundEvents)
                    });
                });
            } catch (e) {
                console.log("Turn resolution skipped or failed:", e);
            }

            selectedCell = null;
            isResolving = false;
        }

        window.handleCellClick = async (r, c) => {
            if (!gameId || !myColor || isResolving || isAnimating || isMoveCommitted) return;

            const cellColor = currentBoardState[r][c];
            let isOverwrite = false;
            if (cellColor !== '') {
                if (cellColor === myColor) return; 
                if (myOverwritesLeft <= 0) return; 
                isOverwrite = true;
            }
            
            selectedCell = { r, c, isOverwrite };
            renderBoard(currentBoardState, { status: 'playing' }); 
        };

        function renderBoard(board, gameData) {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(el => el.remove());
            const waitingScreen = boardElement.querySelector('.col-span-5');
            
            // Only hide waiting screen if actively playing, otherwise keep it (for 'waiting' lobby or 'finished')
            if(gameData.status === 'playing') {
                if(waitingScreen) waitingScreen.classList.add('hidden');
            } else if (gameData.status === 'finished') {
                // Keep board but don't show waiting
                if(waitingScreen) waitingScreen.classList.add('hidden');
            } else {
                if(waitingScreen) waitingScreen.classList.remove('hidden');
            }
            
            const frag = document.createDocumentFragment();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cellVal = board[r][c];
                    const div = document.createElement('div');
                    div.className = `cell w-full h-full flex items-center justify-center text-white font-bold text-lg`;
                    if (cellVal) {
                        div.className += ` ${COLOR_MAP[cellVal].code} occupied-immutable`;
                        if (gameData.status === 'playing' && myColor && cellVal !== myColor && myOverwritesLeft > 0) div.style.cursor = "crosshair";
                    } else {
                        div.classList.add('bg-white');
                    }
                    if (gameData.status === 'playing' && myColor && !isAnimating) {
                        if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
                            div.className = `cell w-full h-full flex items-center justify-center text-white font-bold text-lg ${COLOR_MAP[myColor].code}`;
                            if (selectedCell.isOverwrite) {
                                div.classList.add('breaker-shine', 'ring-4', 'ring-inset', 'ring-black');
                            } else {
                                div.classList.add('ring-4', 'ring-inset', 'ring-black/10');
                            }
                        } else {
                            const isEnemy = cellVal && cellVal !== myColor;
                            if (!cellVal || (isEnemy && myOverwritesLeft > 0)) div.onclick = () => window.handleCellClick(r, c);
                        }
                    }
                    frag.appendChild(div);
                }
            }
            boardElement.insertBefore(frag, boardElement.firstChild);
        }

        window.toggleFriendSelection = (id) => {
            if (selectedFriendIds.has(id)) {
                selectedFriendIds.delete(id);
            } else {
                if (selectedFriendIds.size >= 2) {
                    alert("You can select up to 2 friends.");
                    return;
                }
                selectedFriendIds.add(id);
            }
            if(currentQueueDocs) renderQueueList(currentQueueDocs);
            
            if (selectedFriendIds.size === 2) {
                startFriendsBtn.classList.remove('hidden');
            } else {
                startFriendsBtn.classList.add('hidden');
            }
        };

        function renderQueueList(docs) {
            queueCountEl.textContent = docs.length;
            queueListEl.innerHTML = '';
            if (docs.length === 0) {
                queueListEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-8 uppercase tracking-widest">No players waiting</p>';
                return;
            }
            
            docs.forEach(d => {
                const isMe = d.id === userId;
                const nick = d.data().nickname || "Unknown";
                const el = document.createElement('div');
                
                let bgColor = 'bg-white text-gray-600 border-gray-100';
                
                let contentHTML = ``;
                
                if (isMe) {
                    contentHTML = `<span class="font-bold uppercase">YOU (${nick})</span><span class="text-[10px] uppercase tracking-widest opacity-70">WAITING</span>`;
                    bgColor = 'bg-black text-white border-black';
                } else {
                    const isSelected = selectedFriendIds.has(d.id);
                    contentHTML = `
                        <div class="flex items-center gap-3">
                            <input type="checkbox" class="friend-checkbox" 
                                   ${isSelected ? 'checked' : ''} 
                                   onclick="window.toggleFriendSelection('${d.id}')">
                            <span class="font-bold uppercase ${isSelected ? 'text-black' : ''}">${nick}</span>
                        </div>
                        <span class="text-[10px] uppercase tracking-widest opacity-70">WAITING</span>
                    `;
                    if (isSelected) bgColor = 'bg-yellow-50 border-yellow-400 text-black';
                }

                el.className = `queue-item p-3 border text-xs flex justify-between items-center ${bgColor}`;
                el.innerHTML = contentHTML;

                queueListEl.appendChild(el);
            });
        }

        // --- New: Watch Open Rooms & Logic ---
        function watchOpenRooms() {
            if (unsubscribeOpenRooms) return;

            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const q = query(gamesRef, where('status', '==', 'waiting'), orderBy('createdAt', 'desc'), limit(20));

            unsubscribeOpenRooms = onSnapshot(q, (snapshot) => {
                const listEl = document.getElementById('open-rooms-list');
                const countEl = document.getElementById('open-rooms-count');
                
                if(!listEl) return;

                const rooms = [];
                snapshot.forEach(doc => {
                    rooms.push({ id: doc.id, ...doc.data() });
                });

                countEl.textContent = rooms.length;

                if (rooms.length === 0) {
                    listEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No Open Rooms</p>';
                } else {
                    listEl.innerHTML = '';
                    rooms.forEach(room => {
                        const pCount = Object.keys(room.players).length;
                        const hostName = room.players[room.hostId]?.nickname || 'Unknown';
                        const isMyRoom = (room.players[userId] !== undefined);
                        const rName = room.roomName || 'Room';
                        
                        const el = document.createElement('div');
                        el.className = "flex justify-between items-center p-3 border border-blue-100 bg-blue-50/50 mb-2 rounded hover:bg-blue-100 transition-colors cursor-pointer";
                        el.onclick = () => joinOpenGame(room.id);

                        if (isMyRoom) {
                            el.className += " border-blue-500 ring-1 ring-blue-500";
                        }

                        el.innerHTML = `
                            <div>
                                <div class="text-sm font-black uppercase text-blue-700 leading-tight mb-0.5">${rName}</div>
                                <div class="text-[10px] text-gray-500 font-bold uppercase">HOST: ${hostName}</div>
                            </div>
                            <div class="flex flex-col items-end gap-1">
                                <span class="text-lg font-black text-blue-600">${pCount}/3</span>
                                <span class="text-[10px] bg-blue-600 text-white px-2 py-0.5 rounded font-bold uppercase">JOIN</span>
                            </div>
                        `;
                        listEl.appendChild(el);
                    });
                }
            });
        }

        async function createPublicRoom(roomName) {
            nicknameSection.classList.add('hidden');
            joinBtn.disabled = true; 
            
            // Visual for host
            boardElement.innerHTML = `
                <div class="col-span-5 flex flex-col items-center justify-center h-full bg-white text-black p-4 text-center">
                    <h2 class="text-2xl font-black uppercase mb-2 text-yellow-600">${roomName}</h2>
                    <p class="text-sm font-bold text-gray-500 mb-4">Creating Room...</p>
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-black"></div>
                </div>`;

            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const newGameRef = doc(gamesRef);
            
            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            
            const playersData = {
                [userId]: { 
                    nickname: myNickname, 
                    color: 'R', 
                    isAI: false, 
                    score: 0, 
                    overwrites: MAX_OVERWRITES, 
                    lastMove: null 
                }
            };

            await setDoc(newGameRef, {
                status: 'waiting', 
                turn: 1, 
                turnDeadline: 0, 
                board: JSON.stringify(initialBoard), 
                players: playersData,
                playerOrder: [userId],
                hostId: userId, 
                roomName: roomName,
                createdAt: serverTimestamp(),
                lastRoundEvents: "[]"
            });

            enterGame(newGameRef.id);
        }

        async function joinOpenGame(targetGameId) {
            if (!myNickname) {
                const val = nicknameInput.value.trim();
                if(val) myNickname = val.toUpperCase().slice(0, 10);
                else {
                    alert("Please enter a nickname first.");
                    nicknameInput.focus();
                    return;
                }
            }

            if(window.SoundManager) window.SoundManager.init();

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', targetGameId);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Game does not exist!";
                    
                    const data = gameDoc.data();
                    if (data.status !== 'waiting') throw "Game already started or finished!";
                    
                    const players = data.players;
                    const playerIds = Object.keys(players);
                    
                    if (players[userId]) return; 

                    if (playerIds.length >= 3) throw "Room is full!";

                    const nextColorIndex = playerIds.length; 
                    const nextColor = COLORS[nextColorIndex];

                    players[userId] = {
                        nickname: myNickname,
                        color: nextColor,
                        isAI: false,
                        score: 0,
                        overwrites: MAX_OVERWRITES,
                        lastMove: null
                    };

                    const newOrder = [...data.playerOrder, userId];
                    let newStatus = 'waiting';
                    let newDeadline = data.turnDeadline;

                    if (newOrder.length === 3) {
                        newStatus = 'playing';
                        newDeadline = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
                    }

                    transaction.update(gameRef, {
                        players: players,
                        playerOrder: newOrder,
                        status: newStatus,
                        turnDeadline: newDeadline
                    });
                });

                enterGame(targetGameId);

            } catch (e) {
                console.error("Join Failed:", e);
                alert("Failed to join: " + e);
            }
        }

        function renderScoreboard(players) {
            scoreList.innerHTML = '';
            COLORS.forEach(colorCode => {
                const playerEntry = Object.entries(players).find(([uid, p]) => p.color === colorCode);
                let score = 0; let label = "EMPTY"; let isMe = false; let overwrites = 0;
                if (playerEntry) {
                    const [uid, p] = playerEntry; score = p.score; overwrites = p.overwrites;
                    if (p.isAI) label = p.nickname;
                    else if (uid === userId) { label = p.nickname + " (YOU)"; isMe = true; }
                    else label = p.nickname;
                }
                const li = document.createElement('li');
                li.className = "flex justify-between items-center p-3 bg-white border border-gray-100 shadow-sm";
                li.innerHTML = `<div class="flex items-center gap-3"><div class="w-4 h-4 rounded-full ${COLOR_MAP[colorCode].code}"></div><div class="flex flex-col"><span class="text-sm font-bold uppercase tracking-wider ${isMe ? 'text-black' : 'text-gray-600'}">${label}</span>${playerEntry ? `<span class="text-[10px] text-gray-400">BREAKERS: ${overwrites}</span>` : ''}</div></div><span class="font-mono font-black text-xl">${score}</span>`;
                scoreList.appendChild(li);
            });
        }
        
        function applyOthello(board, r, c, color) {
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
            let flippedCells = [];
            
            dirs.forEach(([dr, dc]) => {
                let nr = r + dr, nc = c + dc, flippable = [];
                let foundOwnColor = false;

                while(nr>=0 && nr<BOARD_SIZE && nc>=0 && nc<BOARD_SIZE) {
                    const cellColor = board[nr][nc];
                    if(cellColor === '') break; 
                    if(cellColor === color) {
                        foundOwnColor = true;
                        break; 
                    }
                    flippable.push({r:nr, c:nc});
                    nr += dr; nc += dc;
                }
                if(foundOwnColor) flippedCells = flippedCells.concat(flippable);
            });
            return flippedCells;
        }

        function getRandomMove(board) {
            let empties = [];
            for(let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) if(board[r][c] === '') empties.push({r,c});
            return empties.length ? empties[Math.floor(Math.random()*empties.length)] : null;
        }

        function showWinner(players) {
             const winner = Object.values(players).sort((a, b) => b.score - a.score)[0];
             const myScore = players[userId]?.score || 0;
             const isWin = players[userId] && winner.color === players[userId].color;
             const title = isWin ? "VICTORY" : "GAME OVER";
             const content = `WINNER: ${winner.nickname} (${winner.score})\nYOUR SCORE: ${myScore}`;
             document.getElementById('modal-title').textContent = title;
             document.getElementById('modal-content').textContent = content;
             document.getElementById('message-modal').classList.remove('hidden');
        }

        window.triggerRematch = async () => {
             document.getElementById('message-modal').classList.add('hidden');
             
             if (!gameId) return;
             
             document.getElementById('modal-content').textContent = "Restarting...";

             const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
             const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
             const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
             
             try {
                 await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(gameRef);
                    if (!sfDoc.exists()) return;

                    const data = sfDoc.data();
                    const players = data.players;
                    const newPlayers = {};

                    for (const pid in players) {
                        newPlayers[pid] = {
                            ...players[pid],
                            score: 0,
                            overwrites: MAX_OVERWRITES,
                            lastMove: null
                        };
                    }

                    transaction.update(gameRef, {
                        status: 'playing',
                        turn: 1,
                        turnDeadline: deadLine,
                        board: JSON.stringify(initialBoard),
                        players: newPlayers,
                        lastRoundEvents: "[]"
                    });
                 });
             } catch (e) {
                 console.error("Rematch failed:", e);
                 resetLocalStateAndUI();
             }
        };

        function setupPlayAgainListener() {
            const btn = document.getElementById('modal-play-again');
            if(btn) {
                btn.onclick = () => window.triggerRematch();
            }
        }
        setupPlayAgainListener();
    </script>
</body>
</html>