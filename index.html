<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COLOR - Final Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');
        
        body { 
            font-family: 'Montserrat', sans-serif; 
            background-color: #f0f0f0; 
            color: #1a1a1a;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Animations --- */
        @keyframes rainbowCycle {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes shine-pulse {
            0% { transform: scale(0.9); filter: brightness(1.5); box-shadow: 0 0 0 0 rgba(255,255,255,0.7); }
            50% { transform: scale(1.05); filter: brightness(1.2); box-shadow: 0 0 20px 5px rgba(255,255,255,0.5); }
            100% { transform: scale(1); filter: brightness(1); box-shadow: 0 0 0 0 rgba(255,255,255,0); }
        }

        @keyframes vanish-anim {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }

        @keyframes flip-anim {
            0% { transform: perspective(400px) rotateY(0); }
            50% { transform: perspective(400px) rotateY(90deg); filter: brightness(2); }
            100% { transform: perspective(400px) rotateY(0); }
        }

        .title-rainbow {
            background: linear-gradient(to right, #ff0000, #ff8800, #ffff00, #008000, #0000ff, #4b0082, #ee82ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% auto;
            animation: rainbowCycle 10s linear infinite;
        }

        .bg-waiting-rainbow {
            background: linear-gradient(45deg, #ff0000, #ffa500, #ffff00, #008000, #0000ff, #4b0082, #ee82ee, #ff0000);
            background-size: 400% 400%;
            animation: rainbowCycle 20s ease infinite;
        }

        .overwrite-box {
            width: 14px; height: 14px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            margin: 0 2px;
            transition: opacity 0.3s ease-out;
        }

        .bg-player-red { background-color: rgb(255, 0, 0); }
        .bg-player-yellow { background-color: rgb(255, 255, 0); }
        .bg-player-blue { background-color: rgb(0, 0, 255); }

        .text-player-red { color: rgb(255, 0, 0); }
        .text-player-yellow { color: rgb(210, 180, 0); } 
        .text-player-blue { color: rgb(0, 0, 255); }

        .cell { transition: transform 0.1s ease-in-out; }
        .cell:hover:not(.occupied-immutable) { filter: brightness(0.9); cursor: pointer; }
        
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
        .queue-item { animation: slideIn 0.3s ease-out forwards; }

        .modal-content { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        /* Custom Checkbox */
        .friend-checkbox {
            appearance: none; background-color: #fff; margin: 0;
            font: inherit; color: currentColor; width: 1.15em; height: 1.15em;
            border: 2px solid currentColor; display: grid; place-content: center; cursor: pointer;
        }
        .friend-checkbox::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0);
            transition: 120ms transform ease-in-out; box-shadow: inset 1em 1em black;
            transform-origin: center; clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .friend-checkbox:checked::before { transform: scale(1); }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d4d4d4; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-2 md:p-8" onclick="SoundManager.init()">

    <div id="create-room-modal" class="hidden fixed inset-0 z-[60] flex items-center justify-center backdrop-blur-sm bg-black/40">
        <div class="modal-content bg-white p-8 w-[90%] max-w-md shadow-2xl border-2 border-black text-center">
            <h3 class="text-3xl font-black uppercase mb-6 tracking-tighter">CREATE ROOM</h3>
            <input type="text" id="room-name-input" placeholder="ROOM NAME" maxlength="12" 
                   class="w-full bg-gray-100 border-2 border-gray-300 p-4 font-bold text-center uppercase tracking-widest focus:outline-none focus:border-black mb-6 text-xl">
            <div class="flex gap-3">
                <button id="confirm-create-btn" class="flex-1 bg-black text-white hover:bg-gray-800 font-bold py-4 text-sm tracking-widest uppercase transition-colors">CREATE</button>
                <button onclick="document.getElementById('create-room-modal').classList.add('hidden')" class="flex-1 bg-white text-black border-2 border-black hover:bg-gray-100 font-bold py-4 text-sm tracking-widest uppercase transition-colors">CANCEL</button>
            </div>
        </div>
    </div>

    <div id="invite-modal" class="hidden fixed inset-0 z-[70] flex items-center justify-center backdrop-blur-md bg-blue-900/40">
        <div class="modal-content bg-white p-8 w-[90%] max-w-sm shadow-2xl border-2 border-blue-600 text-center relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-2 bg-blue-600"></div>
            <h3 class="text-2xl font-black uppercase mb-2 tracking-tighter text-blue-700">INVITATION</h3>
            <p class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-6">YOU HAVE BEEN INVITED</p>
            
            <div class="mb-8">
                <p class="text-sm font-bold text-gray-500 mb-1">HOST</p>
                <p id="invite-host-name" class="text-xl font-black uppercase mb-3">PLAYER</p>
                <p class="text-sm font-bold text-gray-500 mb-1">ROOM</p>
                <p id="invite-room-name" class="text-xl font-black uppercase text-blue-600">ROOM NAME</p>
            </div>

            <div class="flex gap-3">
                <button id="accept-invite-btn" class="flex-1 bg-blue-600 text-white hover:bg-blue-700 font-bold py-4 text-sm tracking-widest uppercase transition-colors shadow-lg">YES</button>
                <button id="decline-invite-btn" class="flex-1 bg-white text-gray-500 border-2 border-gray-200 hover:border-gray-400 font-bold py-4 text-sm tracking-widest uppercase transition-colors">NO</button>
            </div>
        </div>
    </div>

    <div id="game-container" class="w-full max-w-7xl bg-white shadow-2xl flex flex-col lg:flex-row min-h-[700px] border border-gray-300">
        
        <div class="flex-1 flex flex-col p-6 md:p-10 relative">
            
            <div class="mb-8 flex justify-between items-end">
                <h1 class="text-6xl md:text-7xl font-black tracking-tighter title-rainbow">COLOR</h1>
                <div id="desktop-timer-container" class="text-right hidden md:block">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TIMER</p>
                    <p class="text-5xl font-mono font-bold leading-none" id="timer-display">--</p>
                </div>
            </div>

            <div id="my-info-mobile" class="flex md:hidden justify-between items-end border-b-2 border-black pb-4 mb-6">
                <div>
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">PLAYER</p>
                    <p class="text-lg font-black uppercase tracking-tight truncate" id="my-nickname-mobile" style="color:#1a1a1a;">-</p>
                </div>
                <div id="mobile-timer-container" class="text-right">
                    <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">TURN TIMER</p>
                    <p class="text-4xl font-mono font-bold leading-none" id="timer-display-mobile">--</p>
                </div>
            </div>

            <div class="flex-1 flex items-center justify-center min-h-[400px] mb-8">
                <div id="game-board" class="relative grid grid-cols-5 gap-px bg-gray-300 p-px w-full max-w-[600px] aspect-square border-2 border-gray-300 shadow-lg">
                    
                    <div class="col-span-5 flex items-center justify-center h-full text-white text-xl font-bold tracking-widest uppercase bg-waiting-rainbow shadow-inner">
                        Waiting for match
                    </div>

                    <div id="message-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/30">
                        <div class="modal-content bg-white/20 border border-white/40 p-6 w-[80%] max-w-sm text-center backdrop-blur-md shadow-[0_8px_32px_0_rgba(31,38,135,0.37)] rounded-xl relative">
                            <!-- X Button: Now just closes the modal -->
                            <button onclick="document.getElementById('message-modal').classList.add('hidden')" class="absolute top-2 right-3 text-white text-2xl font-bold p-1 leading-none hover:text-gray-300">&times;</button>
                            
                            <h3 id="modal-title" class="text-2xl font-black uppercase mb-3 tracking-tighter text-white drop-shadow-md">TITLE</h3>
                            <p id="modal-content" class="text-white mb-6 font-bold whitespace-pre-line leading-relaxed text-sm drop-shadow-sm">Content</p>
                            
                            <div class="flex flex-col gap-2 w-full">
                                <button id="modal-play-again" class="w-full bg-black hover:bg-gray-800 text-white border border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl">
                                    RESTART GAME
                                </button>
                                <button id="modal-return-lobby" onclick="window.returnToLobby()" class="w-full bg-white hover:bg-gray-100 text-black border border-black font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl">
                                    RETURN TO LOBBY
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col items-center mt-auto w-full">
                
                <div id="overwrite-ui-container" class="w-full max-w-[600px] flex justify-end items-center px-2 mb-4 hidden">
                    <p class="text-xs font-bold text-gray-500 uppercase tracking-widest mr-2">OVERWRITE</p>
                    <div id="overwrite-ui-display" class="flex items-center"></div>
                </div>

                <div class="flex flex-col gap-3 w-full max-w-md">
                    <div id="nickname-section" class="w-full">
                        <input type="text" id="nickname-input" placeholder="ENTER YOUR NAME" maxlength="10" 
                               class="w-full bg-gray-100 border-2 border-gray-200 p-4 font-bold text-center uppercase tracking-widest focus:outline-none focus:border-black transition-colors mb-3">
                        <button id="join-queue-btn" disabled
                                class="w-full bg-black text-white hover:bg-gray-800 font-bold py-4 text-sm tracking-widest uppercase transition-colors disabled:opacity-30 disabled:cursor-not-allowed mb-2">
                            Find Match
                        </button>
                    </div>

                    <div id="game-buttons" class="hidden flex flex-col gap-2 w-full">
                         <button id="start-3p-quick-btn" class="hidden w-full bg-gradient-to-r from-red-600 via-yellow-500 to-blue-600 text-white font-black py-4 text-sm tracking-widest uppercase transition-all shadow-lg hover:scale-[1.02]">
                             Start 3P Quick Match
                         </button>

                         <button id="start-friends-btn" class="hidden w-full bg-black text-white border-2 border-black hover:bg-gray-800 font-bold py-3 text-sm tracking-widest uppercase transition-colors">
                             Start with Selected (3P)
                         </button>

                         <div class="flex gap-2 w-full">
                             <button id="force-ai-btn" class="flex-1 bg-white text-black border-2 border-black hover:bg-black hover:text-white font-bold py-3 text-xs tracking-widest uppercase transition-colors">
                                 Solo AI
                             </button>
                             <button id="create-room-btn" class="flex-1 bg-blue-600 text-white border-2 border-blue-600 hover:bg-blue-700 font-bold py-3 text-xs tracking-widest uppercase transition-colors">
                                Create Open Room
                             </button>
                         </div>
                         <p class="text-[10px] text-gray-400 text-center font-bold uppercase mt-2">Wait for match or select options above</p>
                    </div>
                </div>
            </div>
            
            <span id="my-nickname-display" class="hidden"></span>
            <span id="my-color-display" class="hidden"></span>
        </div>

        <div class="w-full lg:w-96 bg-gray-50 border-t lg:border-t-0 lg:border-l border-gray-200 p-8 flex flex-col gap-4 h-full max-h-screen overflow-hidden">
            
            <div id="scores-section" class="hidden shrink-0">
                <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-2">SCORES</p>
                <ul id="score-list" class="space-y-2">
                    <li class="text-gray-300 text-xs uppercase tracking-widest py-2">Game not started</li>
                </ul>
            </div>

            <div id="lobby-panels" class="flex-1 flex flex-col gap-4 overflow-hidden min-h-0">
                
                <div id="queue-section" class="flex-1 flex flex-col min-h-0 bg-white border border-gray-200 p-4 shadow-sm">
                    <div class="flex justify-between items-center mb-2 border-b border-gray-100 pb-2 shrink-0">
                        <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">QUEUE</p>
                        <span id="queue-count" class="text-xs font-bold bg-black text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="queue-list" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        <p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No players waiting</p>
                    </div>
                </div>

                <div id="open-rooms-section" class="flex-1 flex flex-col min-h-0 bg-white border border-gray-200 p-4 shadow-sm">
                    <div class="flex justify-between items-center mb-2 border-b border-gray-100 pb-2 shrink-0">
                        <p class="text-[10px] font-bold text-blue-600 uppercase tracking-widest">OPEN ROOMS</p>
                        <span id="open-rooms-count" class="text-xs font-bold bg-blue-600 text-white px-2 py-0.5">0</span>
                    </div>
                    <div id="open-rooms-list" class="flex-1 overflow-y-auto space-y-2 pr-2">
                        <p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No Open Rooms</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, 
            query, where, getDocs, runTransaction, serverTimestamp, orderBy, limit, deleteField 
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Sound Manager ---
        window.SoundManager = {
            ctx: null,
            init: function() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.playAmbient();
                
                document.addEventListener('visibilitychange', async () => {
                    if (document.visibilityState === 'hidden') {
                        if (queueDocId && !gameId) {
                            await leaveQueue(); 
                            resetLocalStateAndUI(); 
                        }
                    }
                });
                window.addEventListener('beforeunload', () => {
                    if (queueDocId && !gameId) { leaveQueue(); }
                });
            },
            playAmbient: function() {
                const t = this.ctx.currentTime;
                const gain = this.ctx.createGain();
                gain.connect(this.ctx.destination);
                const freqs = [261.63, 329.63, 392.00, 493.88]; 
                freqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                    osc.frequency.value = f;
                    const oscGain = this.ctx.createGain();
                    oscGain.gain.value = 0.03; 
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 0.1 + (i * 0.05);
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 0.01;
                    lfo.connect(lfoGain);
                    lfoGain.connect(oscGain.gain);
                    lfo.start();
                    osc.connect(oscGain);
                    oscGain.connect(gain);
                    osc.start();
                });
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.5, t + 5); 
            },
            playGlass: function() { 
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1500, t); 
                osc.frequency.exponentialRampToValueAtTime(1500, t + 1); 
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.4, t + 0.01); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); 
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t); osc.stop(t + 1.5);
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(3000, t);
                gain2.gain.setValueAtTime(0, t);
                gain2.gain.linearRampToValueAtTime(0.05, t + 0.01);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
                gain2.connect(this.ctx.destination);
                osc2.start(t); osc2.stop(t + 1.0);
            },
            playConflict: function() { 
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(t); osc.stop(t + 0.5);
            },
            playTick: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                osc.type = 'square';
                filter.type = 'highpass';
                filter.frequency.value = 2000;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(800, t);
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(); osc.stop(t + 0.05);
            }
        };

        // --- Config ---
        const BOARD_SIZE = 5;
        const TURN_DURATION_MS = 5000; 
        const FIRST_TURN_DURATION_MS = 10000; 
        const NETWORK_BUFFER_MS = 1000;
        const MAX_OVERWRITES = 3; 
        const COLORS = ['R', 'Y', 'B']; 
        const COLOR_MAP = {
            'R': { code: 'bg-player-red', text: 'text-player-red', label: 'RED', html_color: 'rgb(255, 0, 0)' },
            'Y': { code: 'bg-player-yellow', text: 'text-player-yellow', label: 'YELLOW', html_color: 'rgb(210, 180, 0)' },
            'B': { code: 'bg-player-blue', text: 'text-player-blue', label: 'BLUE', html_color: 'rgb(0, 0, 255)' },
        };
        const firebaseConfig = {
            apiKey: "AIzaSyA1DEzZvw6_63cLUk_YeWYRInZ0drIzd5Q",
            authDomain: "color-a6d38.firebaseapp.com",
            projectId: "color-a6d38",
            storageBucket: "color-a6d38.firebasestorage.app",
            messagingSenderId: "761735384766",
            appId: "1:761735384766:web:cc52566ccafac650a558ef"
        };
        const appId = 'Color-Game-V7-Conflict';

        let app, db, auth, userId;
        let myNickname = "";
        let queueDocId = null;
        let gameId = null;
        let myColor = null;
        let myOverwritesLeft = MAX_OVERWRITES;
        let currentQueueDocs = []; 
        let lastProcessedTurn = 0; 
        let isAnimating = false; 
        let pendingBoardState = null; 
        let pendingGameEndData = null; 
        let selectedFriendIds = new Set(); 
        let currentInvitedGameId = null; 
        
        let unsubscribeQueue = null;
        let unsubscribeGame = null;
        let unsubscribeMyTicket = null;
        let unsubscribeOpenRooms = null;
        
        // Host state
        let isWaitingRoomHost = false;
        let myHostedRoomName = "";

        const nicknameInput = document.getElementById('nickname-input');
        const nicknameSection = document.getElementById('nickname-section');
        const joinBtn = document.getElementById('join-queue-btn');
        const createRoomBtn = document.getElementById('create-room-btn');
        const gameButtonsDiv = document.getElementById('game-buttons');
        const aiBtn = document.getElementById('force-ai-btn');
        const start3pBtn = document.getElementById('start-3p-quick-btn');
        const startFriendsBtn = document.getElementById('start-friends-btn');
        const queueListEl = document.getElementById('queue-list');
        const queueCountEl = document.getElementById('queue-count');
        const boardElement = document.getElementById('game-board');
        const timerDisplay = document.getElementById('timer-display');
        const timerDisplayMobile = document.getElementById('timer-display-mobile');
        const scoresSection = document.getElementById('scores-section');
        const lobbyPanels = document.getElementById('lobby-panels');
        const scoreList = document.getElementById('score-list');
        const desktopTimerContainer = document.getElementById('desktop-timer-container');
        const mobileTimerContainer = document.getElementById('mobile-timer-container');
        const myNicknameDisplay = document.getElementById('my-nickname-display');
        const myColorDisplay = document.getElementById('my-color-display'); 
        const myNicknameMobile = document.getElementById('my-nickname-mobile'); 
        const overwriteUIDisplay = document.getElementById('overwrite-ui-display');
        const overwriteUIContainer = document.getElementById('overwrite-ui-container');

        let currentBoardState = [];
        let selectedCell = null; 
        let isResolving = false;
        let localTimerInterval = null;
        let lastTimerValue = ""; 
        let lastGameMode = null; 
        let isMoveCommitted = false; 

        // --- Strict Queue Watchdog ---
        let queueKickTimer = null;
        const STRICT_QUEUE_TIMEOUT = 30000; 

        function startQueueWatchdog() {
            resetQueueWatchdog();
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.addEventListener(evt, resetQueueWatchdog);
            });
        }
        function stopQueueWatchdog() {
            if (queueKickTimer) clearTimeout(queueKickTimer);
            ['mousemove', 'keydown', 'click', 'touchstart'].forEach(evt => {
                document.removeEventListener(evt, resetQueueWatchdog);
            });
        }
        function resetQueueWatchdog() {
            if (queueKickTimer) clearTimeout(queueKickTimer);
            if (queueDocId && !gameId) {
                queueKickTimer = setTimeout(async () => {
                    await leaveQueue();
                    resetLocalStateAndUI();
                }, STRICT_QUEUE_TIMEOUT);
            }
        }

        async function init() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            try {
                const credential = await signInAnonymously(auth);
                userId = credential.user.uid; 
            } catch (error) { console.error("Auth failed:", error); }
            onAuthStateChanged(auth, (user) => { if (user && !userId) userId = user.uid; });

            mobileTimerContainer.classList.add('hidden');
            overwriteUIContainer.classList.add('hidden');
            
            watchQueueList();
            watchOpenRooms();
            startCleanupInterval(); // Start cleanup loop
        }
        window.onload = init;

        // --- Periodic Cleanup for Stale Rooms ---
        function startCleanupInterval() {
            setInterval(async () => {
                // Every 5 seconds, find rooms that are stuck (e.g., created > 30 seconds ago and still waiting) or empty
                const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
                const thirtySecondsAgo = new Date(Date.now() - 30 * 1000); 
                
                try {
                    // Query for waiting rooms
                    const q = query(gamesRef, where('status', '==', 'waiting'));
                    const snap = await getDocs(q);
                    
                    snap.forEach(async (docSnap) => {
                        const data = docSnap.data();
                        const createdTime = data.createdAt ? data.createdAt.toDate() : new Date();
                        
                        // Rule 1: Delete if older than 30 seconds and still waiting (Abandoned/Timeout)
                        const isStale = createdTime < thirtySecondsAgo;
                        
                        // Rule 2: Delete if it has no players (Bugged)
                        const isEmpty = !data.players || Object.keys(data.players).length === 0;

                        if (isStale || isEmpty) {
                            console.log(`Deleting stale room: ${docSnap.id}`);
                            await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', docSnap.id));
                        }
                    });
                } catch (e) {
                    console.error("Cleanup error:", e);
                }
            }, 5000); // Check every 5 seconds
        }

        nicknameInput.addEventListener('input', (e) => {
            joinBtn.disabled = e.target.value.trim().length === 0;
        });

        // --- Create Room Modal Logic ---
        const createRoomModal = document.getElementById('create-room-modal');
        const roomNameInput = document.getElementById('room-name-input');
        const confirmCreateBtn = document.getElementById('confirm-create-btn');

        createRoomBtn.addEventListener('click', () => {
            if(window.SoundManager) window.SoundManager.init();
            roomNameInput.value = "";
            createRoomModal.classList.remove('hidden');
            roomNameInput.focus();
        });

        confirmCreateBtn.addEventListener('click', async () => {
            const rName = roomNameInput.value.trim();
            if(!rName) {
                alert("Please enter a room name");
                return;
            }
            createRoomModal.classList.add('hidden');
            await leaveQueue(); 
            await createPublicRoom(rName);
        });

        // --- Invite Modal Logic ---
        const inviteModal = document.getElementById('invite-modal');
        const acceptInviteBtn = document.getElementById('accept-invite-btn');
        const declineInviteBtn = document.getElementById('decline-invite-btn');

        acceptInviteBtn.addEventListener('click', async () => {
             inviteModal.classList.add('hidden');
             if(currentInvitedGameId) {
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), {
                    invite: deleteField()
                 });
                 await joinOpenGame(currentInvitedGameId);
                 currentInvitedGameId = null;
             }
        });

        declineInviteBtn.addEventListener('click', async () => {
            inviteModal.classList.add('hidden');
            currentInvitedGameId = null;
            if(queueDocId) {
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', userId), {
                    invite: deleteField()
                 });
            }
        });

        async function performJoinQueue() {
            if (!userId) return;
            if(window.SoundManager) window.SoundManager.init();

            nicknameSection.classList.add('hidden'); 
            gameButtonsDiv.classList.remove('hidden'); 
            myNicknameDisplay.textContent = myNickname;
            myNicknameMobile.textContent = myNickname; 
            joinBtn.textContent = "SEARCHING...";
            joinBtn.disabled = true;
            nicknameInput.disabled = true;
            selectedFriendIds.clear();

            try {
                const queueRef = collection(db, 'artifacts', appId, 'public', 'data', 'queue');
                const ticketRef = doc(queueRef, userId);
                await setDoc(ticketRef, { 
                    userId: userId, 
                    nickname: myNickname,
                    joinedAt: serverTimestamp(), 
                    matchId: null 
                });
                queueDocId = userId;
                startQueueWatchdog();
                watchMyTicket(ticketRef);
            } catch (e) {
                resetLocalStateAndUI();
            }
        }

        joinBtn.addEventListener('click', async () => {
            const val = nicknameInput.value.trim();
            if(!val) return;
            myNickname = val.toUpperCase().slice(0, 10);
            await performJoinQueue();
        });

        function watchMyTicket(docRef) {
            unsubscribeMyTicket = onSnapshot(docRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (queueDocId) resetLocalStateAndUI();
                    return;
                }
                const data = docSnap.data();
                if (data.matchId) {
                    lastGameMode = 'PVP'; 
                    enterGame(data.matchId);
                }
                if (data.invite && !currentInvitedGameId) {
                    currentInvitedGameId = data.invite.gameId;
                    document.getElementById('invite-host-name').textContent = data.invite.hostName;
                    document.getElementById('invite-room-name').textContent = data.invite.roomName;
                    inviteModal.classList.remove('hidden');
                }
            });
        }

        function watchQueueList() {
            if (unsubscribeQueue) return; 
            const queueRef = collection(db, 'artifacts', appId, 'public', 'data', 'queue');
            const q = query(queueRef, orderBy('joinedAt', 'asc'), limit(12));
            unsubscribeQueue = onSnapshot(q, (snapshot) => {
                const docs = snapshot.docs;
                currentQueueDocs = docs;
                renderQueueList(docs);
                
                if (queueDocId) {
                    if (docs.length >= 3) {
                        start3pBtn.classList.remove('hidden');
                        start3pBtn.textContent = `START 3P GAME (${docs.length} WAITING)`;
                    } else start3pBtn.classList.add('hidden');

                    if (selectedFriendIds.size === 2) startFriendsBtn.classList.remove('hidden');
                    else startFriendsBtn.classList.add('hidden');
                }
            });
        }

        window.invitePlayer = async (targetId) => {
             if (!gameId || !isWaitingRoomHost) return;
             if (targetId === userId) return;

             try {
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', targetId), {
                     invite: {
                         gameId: gameId,
                         roomName: myHostedRoomName,
                         hostName: myNickname
                     }
                 });
             } catch(e) {
                 console.error("Invite failed", e);
             }
        };

        function renderQueueList(docs) {
            queueCountEl.textContent = docs.length;
            queueListEl.innerHTML = '';
            if (docs.length === 0) {
                queueListEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-8 uppercase tracking-widest">No players waiting</p>';
                return;
            }
            
            docs.forEach(d => {
                const isMe = d.id === userId;
                const nick = d.data().nickname || "Unknown";
                const el = document.createElement('div');
                let bgColor = 'bg-white text-gray-600 border-gray-100';
                let contentHTML = ``;
                
                if (isWaitingRoomHost && !isMe) {
                    contentHTML = `
                        <div class="flex items-center gap-3">
                            <span class="font-bold uppercase text-black">${nick}</span>
                        </div>
                        <button onclick="window.invitePlayer('${d.id}')" class="text-[10px] bg-blue-600 hover:bg-blue-700 text-white font-bold px-2 py-1 rounded uppercase tracking-widest">INVITE</button>
                    `;
                    bgColor = 'bg-white border-blue-100';
                } else if (isMe) {
                    contentHTML = `<span class="font-bold uppercase">YOU (${nick})</span><span class="text-[10px] uppercase tracking-widest opacity-70">WAITING</span>`;
                    bgColor = 'bg-black text-white border-black';
                } else {
                    const isSelected = selectedFriendIds.has(d.id);
                    contentHTML = `
                        <div class="flex items-center gap-3">
                            <input type="checkbox" class="friend-checkbox" ${isSelected ? 'checked' : ''} onclick="window.toggleFriendSelection('${d.id}')">
                            <span class="font-bold uppercase ${isSelected ? 'text-black' : ''}">${nick}</span>
                        </div>
                        <span class="text-[10px] uppercase tracking-widest opacity-70">WAITING</span>
                    `;
                    if (isSelected) bgColor = 'bg-yellow-50 border-yellow-400 text-black';
                }

                el.className = `queue-item p-3 border text-xs flex justify-between items-center ${bgColor}`;
                el.innerHTML = contentHTML;
                queueListEl.appendChild(el);
            });
        }

        start3pBtn.addEventListener('click', async () => {
             if(window.SoundManager) window.SoundManager.init();
             if (!queueDocId || currentQueueDocs.length < 3) return;
             const top3 = currentQueueDocs.slice(0, 3);
             await initGameWithPlayers(top3);
        });

        startFriendsBtn.addEventListener('click', async () => {
             if(window.SoundManager) window.SoundManager.init();
             if (!queueDocId || selectedFriendIds.size !== 2) return;
             const selectedDocs = currentQueueDocs.filter(d => d.id === userId || selectedFriendIds.has(d.id));
             if (selectedDocs.length !== 3) { alert("Selected players left."); return; }
             await initGameWithPlayers(selectedDocs);
        });

        aiBtn.addEventListener('click', async () => { await startSoloAiGame(); });

        async function initGameWithPlayers(usersDocs, fillAI = false) {
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const newGameRef = doc(gamesRef);
            const newGameId = newGameRef.id;
            const playersData = {};
            const playerOrder = [];
            usersDocs.forEach((d, idx) => {
                const uid = d.data().userId;
                const nick = d.data().nickname || "Unknown";
                playersData[uid] = { nickname: nick, color: COLORS[idx], isAI: false, score: 0, overwrites: MAX_OVERWRITES, lastMove: null };
                playerOrder.push(uid);
            });
            lastGameMode = 'PVP';
            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
            await runTransaction(db, async (transaction) => {
                transaction.set(newGameRef, {
                    status: 'playing', turn: 1, turnDeadline: deadLine,
                    board: JSON.stringify(initialBoard), players: playersData,
                    playerOrder: playerOrder, hostId: userId, createdAt: serverTimestamp(), lastRoundEvents: "[]"
                });
                for (const d of usersDocs) {
                    const qRef = doc(db, 'artifacts', appId, 'public', 'data', 'queue', d.id);
                    transaction.update(qRef, { matchId: newGameId });
                }
            });
        }

        async function startSoloAiGame() {
            if(window.SoundManager) window.SoundManager.init();
            if (queueDocId) await leaveQueue();
            lastGameMode = 'AI';
            const newGameRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'games'));
            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const playersData = {
                [userId]: { nickname: myNickname, color: 'R', isAI: false, score: 0, overwrites: MAX_OVERWRITES, lastMove: null },
                'AI_Y': { nickname: "AI YELLOW", color: 'Y', isAI: true, score: 0, overwrites: MAX_OVERWRITES, lastMove: null }, 
                'AI_B': { nickname: "AI BLUE", color: 'B', isAI: true, score: 0, overwrites: MAX_OVERWRITES, lastMove: null } 
            };
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
            await setDoc(newGameRef, {
                status: 'playing', turn: 1, turnDeadline: deadLine,
                board: JSON.stringify(initialBoard), players: playersData,
                playerOrder: [userId, 'AI_Y', 'AI_B'], hostId: userId, createdAt: serverTimestamp(),
                lastRoundEvents: "[]"
            });
            enterGame(newGameRef.id);
        }

        async function leaveQueue() {
            stopQueueWatchdog();
            if (unsubscribeMyTicket) { unsubscribeMyTicket(); unsubscribeMyTicket = null; }
            if (queueDocId) {
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'queue', queueDocId));
                queueDocId = null;
            }
        }

        window.returnToLobby = () => {
            resetLocalStateAndUI();
        }

        function resetLocalStateAndUI() {
            stopQueueWatchdog();
            if (localTimerInterval) clearInterval(localTimerInterval);
            if (unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
            if (unsubscribeMyTicket) { unsubscribeMyTicket(); unsubscribeMyTicket = null; }

            watchQueueList(); watchOpenRooms();
            
            queueDocId = null; gameId = null; myColor = null; myOverwritesLeft = MAX_OVERWRITES;
            lastProcessedTurn = 0; isAnimating = false; pendingBoardState = null; pendingGameEndData = null;
            selectedCell = null; isResolving = false; lastTimerValue = ""; isMoveCommitted = false; 
            myNickname = ""; selectedFriendIds.clear(); isWaitingRoomHost = false; myHostedRoomName = "";
            currentInvitedGameId = null;

            inviteModal.classList.add('hidden');
            createRoomModal.classList.add('hidden');
            nicknameSection.classList.remove('hidden');
            gameButtonsDiv.classList.add('hidden');
            nicknameInput.disabled = false; nicknameInput.value = ""; nicknameInput.focus();
            joinBtn.textContent = "Find Match"; joinBtn.disabled = true;
            start3pBtn.classList.add('hidden'); startFriendsBtn.classList.add('hidden');
            myNicknameDisplay.textContent = ''; myNicknameMobile.textContent = '-'; myNicknameMobile.style.color = '#1a1a1a';
            myColorDisplay.textContent = 'SPECTATOR';
            overwriteUIDisplay.innerHTML = ''; overwriteUIContainer.classList.add('hidden');
            scoresSection.classList.add('hidden'); lobbyPanels.classList.remove('hidden');
            mobileTimerContainer.classList.add('hidden');
            updateTimerDisplay("--");
            scoreList.innerHTML = '<li class="text-gray-300 text-xs uppercase tracking-widest py-2">Game not started</li>';
            
            // Reset modal completely
            const modal = document.getElementById('message-modal');
            modal.classList.add('hidden');
            
            boardElement.innerHTML = `<div class="col-span-5 flex items-center justify-center h-full text-white text-xl font-bold tracking-widest uppercase bg-waiting-rainbow shadow-inner">Waiting for match</div><div id="message-modal" class="hidden absolute inset-0 z-50 flex items-center justify-center backdrop-blur-[2px] bg-black/30"><div class="modal-content bg-white/20 border border-white/40 p-6 w-[80%] max-w-sm text-center backdrop-blur-md shadow-[0_8px_32px_0_rgba(31,38,135,0.37)] rounded-xl relative"><button onclick="document.getElementById('message-modal').classList.add('hidden')" class="absolute top-2 right-3 text-white text-2xl font-bold p-1 leading-none hover:text-gray-300">&times;</button><h3 id="modal-title" class="text-2xl font-black uppercase mb-3 tracking-tighter text-white drop-shadow-md">TITLE</h3><p id="modal-content" class="text-white mb-6 font-bold whitespace-pre-line leading-relaxed text-sm drop-shadow-sm">Content</p><div class="flex flex-col gap-2 w-full"><button id="modal-play-again" class="w-full bg-black hover:bg-gray-800 text-white border border-white/20 font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl">RESTART GAME</button><button onclick="window.returnToLobby()" class="w-full bg-white hover:bg-gray-100 text-black border border-black font-black py-4 text-sm tracking-[0.2em] uppercase transition-all hover:scale-105 rounded-lg shadow-xl">RETURN TO LOBBY</button></div></div></div>`;
             setupPlayAgainListener();
        }

        async function enterGame(id) {
            stopQueueWatchdog();
            gameId = id;
            await leaveQueue(); 
            if (unsubscribeQueue) { unsubscribeQueue(); unsubscribeQueue = null; }
            nicknameSection.classList.add('hidden');
            gameButtonsDiv.classList.remove('hidden');
            start3pBtn.classList.add('hidden'); startFriendsBtn.classList.add('hidden');
            gameButtonsDiv.classList.add('hidden'); 
            
            unsubscribeGame = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (docSnap) => {
                if(!docSnap.exists()) {
                    if(localTimerInterval) clearInterval(localTimerInterval);
                    resetLocalStateAndUI();
                    return;
                }
                handleGameUpdate(docSnap.data());
            });
            lobbyPanels.classList.add('hidden');
            scoresSection.classList.remove('hidden');
            mobileTimerContainer.classList.remove('hidden'); 
        }

        function renderOverwriteUI(overwritesLeft) {
            overwriteUIDisplay.innerHTML = '';
            for (let i = 0; i < MAX_OVERWRITES; i++) {
                const box = document.createElement('div');
                box.className = 'overwrite-box';
                if (i < overwritesLeft) box.classList.add('bg-waiting-rainbow');
                else box.style.backgroundColor = '#d1d5db'; 
                overwriteUIDisplay.appendChild(box);
            }
            overwriteUIContainer.classList.remove('hidden');
        }

        // --- NEW: KICK & START LOGIC ---
        window.kickPlayerFromRoom = async (targetId) => {
            if (!gameId || !isWaitingRoomHost) return;
            if (targetId === userId) return; // Can't kick self
            
            // REMOVED: if(!confirm("Kick this player?")) return;

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const doc = await transaction.get(gameRef);
                    if (!doc.exists()) return;
                    const data = doc.data();
                    const players = data.players;
                    const order = data.playerOrder;
                    
                    delete players[targetId];
                    const newOrder = order.filter(id => id !== targetId);
                    
                    transaction.update(gameRef, {
                        players: players,
                        playerOrder: newOrder
                    });
                });
            } catch (e) { console.error("Kick failed", e); }
        };

        window.hostStartGame = async () => {
            if (!gameId || !isWaitingRoomHost) return;
            const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
            try {
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    status: 'playing',
                    turnDeadline: deadLine
                });
            } catch(e) { console.error("Start failed", e); }
        };

        function handleGameUpdate(gameData) {
            // Check if I was kicked
            if (gameId && userId && !gameData.players[userId]) {
                // REMOVED: alert("You have been kicked from the room.");
                resetLocalStateAndUI();
                return;
            }

            if (gameData.status === 'waiting') {
                const waitingEl = boardElement.querySelector('.col-span-5');
                if (waitingEl) {
                    const rName = gameData.roomName || 'Room';
                    const players = gameData.players;
                    const pCount = Object.keys(players).length;
                    const hostId = gameData.hostId;
                    const isMeHost = (hostId === userId);

                    let playerListHTML = '';
                    gameData.playerOrder.forEach((pid, idx) => {
                        const p = players[pid];
                        if(p) {
                            const isMe = (pid === userId);
                            const canKick = isMeHost && !isMe;
                            playerListHTML += `
                                <div class="bg-black/10 p-2 mb-2 rounded flex justify-between items-center w-full max-w-xs">
                                    <div class="flex items-center gap-2">
                                        <div class="w-3 h-3 rounded-full ${COLOR_MAP[p.color].code}"></div>
                                        <span class="font-bold text-sm uppercase ${isMe ? 'underline' : ''}">${p.nickname}</span>
                                        ${pid === hostId ? '<span class="text-[10px] bg-yellow-400 text-black px-1 rounded font-bold">HOST</span>' : ''}
                                    </div>
                                    ${canKick ? `<button onclick="window.kickPlayerFromRoom('${pid}')" class="bg-red-500 hover:bg-red-600 text-white text-[10px] font-bold px-2 py-1 rounded uppercase">KICK</button>` : ''}
                                </div>
                            `;
                        }
                    });

                    // Start Button Logic
                    let actionHTML = '';
                    if (isMeHost) {
                         if (pCount === 3) {
                             actionHTML = `<button onclick="window.hostStartGame()" class="mt-4 bg-green-600 hover:bg-green-700 text-white font-black py-3 px-8 text-xl tracking-widest uppercase rounded shadow-lg animate-pulse">START GAME</button>`;
                         } else {
                             actionHTML = `<p class="mt-4 text-xs font-bold text-gray-400 uppercase tracking-widest">Waiting for players (3/3 needed)</p>`;
                         }
                    } else {
                        actionHTML = `<p class="mt-4 text-xs font-bold text-gray-400 uppercase tracking-widest">Waiting for host to start...</p>`;
                    }

                    waitingEl.innerHTML = `
                        <div class="flex flex-col items-center justify-center text-center w-full p-6">
                            <h2 class="text-2xl font-black uppercase mb-6 text-yellow-600 drop-shadow-sm border-b-2 border-yellow-400 pb-2">${rName}</h2>
                            <div class="w-full flex flex-col items-center mb-2">
                                ${playerListHTML}
                            </div>
                            ${actionHTML}
                        </div>`;
                }
                
                const myData = gameData.players[userId];
                if(myData) {
                     myNicknameDisplay.textContent = myData.nickname;
                     myNicknameMobile.textContent = myData.nickname;
                     myColor = myData.color;
                     const cInfo = COLOR_MAP[myColor];
                     myNicknameMobile.style.color = cInfo.html_color;
                     myColorDisplay.textContent = cInfo.label;
                }
                
                // HOST LOGIC: Show Queue in Sidebar to allow invites
                if (gameData.hostId === userId) {
                    isWaitingRoomHost = true;
                    myHostedRoomName = gameData.roomName;
                    lobbyPanels.classList.remove('hidden'); 
                    document.getElementById('open-rooms-section').classList.add('hidden'); 
                    document.getElementById('queue-section').classList.remove('hidden');
                    watchQueueList(); 
                }

                renderScoreboard(gameData.players);
                return;
            }

            // Game Started
            if (isWaitingRoomHost) {
                 isWaitingRoomHost = false;
                 document.getElementById('open-rooms-section').classList.remove('hidden');
                 lobbyPanels.classList.add('hidden');
            }

            const myPlayerData = gameData.players[userId];
            if (myPlayerData && myPlayerData.isAI) {
                if(localTimerInterval) clearInterval(localTimerInterval);
                if(unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
                resetLocalStateAndUI();
                return; 
            }

            lobbyPanels.classList.add('hidden');
            scoresSection.classList.remove('hidden');
            mobileTimerContainer.classList.remove('hidden');

            if (gameData.turn < lastProcessedTurn) {
                lastProcessedTurn = 0; isAnimating = false; pendingGameEndData = null;
                document.getElementById('message-modal').classList.add('hidden');
            }

            const myData = gameData.players[userId];
            if (myData) {
                myColor = myData.color; myOverwritesLeft = myData.overwrites;
                const cInfo = COLOR_MAP[myColor];
                myNicknameDisplay.textContent = myData.nickname; myNicknameMobile.textContent = myData.nickname;
                myNicknameMobile.style.color = cInfo.html_color; myColorDisplay.textContent = cInfo.label;
                renderOverwriteUI(myOverwritesLeft);
            } else {
                 myNicknameMobile.style.color = '#1a1a1a'; myColorDisplay.textContent = 'SPECTATOR';
                 overwriteUIContainer.classList.add('hidden');
            }
            
            // --- FIX: Reliable Game Over Logic ---
            // Determine if a new turn animation is needed
            const isNewTurn = gameData.turn > lastProcessedTurn;

            // Handle Finished Status
            if (gameData.status === 'finished') {
                if (localTimerInterval) clearInterval(localTimerInterval);
                updateTimerDisplay("0");
                
                // If NO new turn animation is pending, show result immediately.
                // If animation IS pending, the callback in triggerSequentialAnimations will handle it.
                if (!isNewTurn && !isAnimating) {
                    showWinner(gameData.players);
                }
            }

            if (isNewTurn) {
                // Start Animation
                isMoveCommitted = false; selectedCell = null;
                isAnimating = true;
                
                // FIX: Set pendingBoardState BEFORE calling animation function which uses it
                pendingBoardState = JSON.parse(gameData.board); 
                
                // Important: Pass the LATEST gameData to the animation function
                triggerSequentialAnimations(JSON.parse(gameData.lastRoundEvents || "[]"), gameData);
                
                lastProcessedTurn = gameData.turn;
            } else if (!isAnimating) {
                // Just render the static board
                currentBoardState = JSON.parse(gameData.board);
                renderBoard(currentBoardState, gameData);
            }
            
            renderScoreboard(gameData.players);
            if (gameData.status === 'playing') runClientTimer(gameData.turnDeadline, gameData);
        }

        function triggerSequentialAnimations(events, gameData) {
            if (!events || events.length === 0) {
                isAnimating = false; currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);
                // --- FIX: Direct check for finished status ---
                if (gameData.status === 'finished') {
                    setTimeout(() => { showWinner(gameData.players); }, 500);
                }
                return;
            }
            let accumulatedDelay = 0;
            events.forEach((ev, index) => {
                const cellIdx = (ev.r * BOARD_SIZE) + ev.c;
                // --- FIX: Faster Animations (10% Slower than previous fast version) ---
                let duration = 660; // Was 600
                if(ev.type === 'flip') duration = 330; // Was 300
                else if (ev.type === 'conflict') duration = (ev.colors.length * 550) + 550; // Was 500/500
                setTimeout(() => {
                    const cells = boardElement.querySelectorAll('.cell');
                    if (cells[cellIdx]) {
                        const cell = cells[cellIdx];
                        cell.style.animation = 'none'; cell.offsetHeight; cell.style.animation = null; 
                        if (ev.type === 'conflict') {
                            if(window.SoundManager) window.SoundManager.playConflict();
                            const sortOrder = ['R', 'Y', 'B'];
                            const colors = (ev.colors || []).sort((a, b) => sortOrder.indexOf(a) - sortOrder.indexOf(b));
                            colors.forEach((cCode, i) => {
                                setTimeout(() => {
                                    if(window.SoundManager) window.SoundManager.playGlass(); 
                                    cell.classList.remove('bg-white', 'bg-player-red', 'bg-player-yellow', 'bg-player-blue');
                                    cell.classList.add(COLOR_MAP[cCode].code);
                                    cell.style.animation = 'shine-pulse 0.55s forwards'; // Slower pulse
                                }, i * 550); // Slower Interval
                            });
                            setTimeout(() => { cell.style.animation = 'vanish-anim 0.55s forwards'; }, colors.length * 550);
                        } else if (ev.type === 'success') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            cell.classList.remove('bg-white'); cell.classList.add(COLOR_MAP[ev.color].code);
                            cell.style.animation = 'shine-pulse 0.55s forwards'; 
                        } else if (ev.type === 'flip') {
                            if(window.SoundManager) window.SoundManager.playGlass();
                            COLORS.forEach(c => cell.classList.remove(COLOR_MAP[c].code));
                            cell.classList.add(COLOR_MAP[ev.color].code);
                            cell.style.animation = 'flip-anim 0.33s forwards'; 
                        }
                    }
                }, accumulatedDelay);
                accumulatedDelay += duration;
            });
            setTimeout(() => {
                isAnimating = false; currentBoardState = pendingBoardState;
                renderBoard(currentBoardState, gameData);
                // --- FIX: Robust finish check ---
                if (gameData.status === 'finished') {
                     setTimeout(() => { showWinner(gameData.players); }, 300); // Fast popup
                }
            }, accumulatedDelay);
        }

        function updateTimerDisplay(text) {
            const displayText = isAnimating ? "0" : text;
            if(lastTimerValue !== displayText) {
                if(window.SoundManager && displayText !== "0" && displayText !== "--") window.SoundManager.playTick();
                lastTimerValue = displayText;
            }
            timerDisplay.textContent = displayText;
            document.getElementById('timer-display-mobile').textContent = displayText;
            if(displayText === "0") {
                 const cls = "font-mono font-bold leading-none text-gray-300";
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            } else {
                const val = parseInt(displayText);
                let colorClass = "text-black";
                if(val <= 2) colorClass = "text-red-600";
                const cls = `font-mono font-bold leading-none ${colorClass}`;
                 timerDisplay.className = "text-5xl " + cls;
                 document.getElementById('timer-display-mobile').className = "text-4xl " + cls;
            }
        }

        function runClientTimer(deadline, gameData) {
            if (localTimerInterval) clearInterval(localTimerInterval);
            const updateTimer = () => {
                if (isAnimating) { updateTimerDisplay("0"); return; }
                const now = Date.now();
                const totalDiff = deadline - now;
                const visualDiff = totalDiff - NETWORK_BUFFER_MS;
                if (visualDiff <= 500 && !isMoveCommitted && selectedCell) commitCurrentMove();
                let secondsLeft = Math.ceil(visualDiff / 1000);
                if (secondsLeft > 0) updateTimerDisplay(secondsLeft.toString());
                else {
                    updateTimerDisplay("0");
                    const isHost = userId === gameData.hostId;
                    const buffer = isHost ? 0 : 3000; 
                    if (!isResolving && now > deadline + buffer) resolveTurn(gameData);
                }
            };
            updateTimer();
            localTimerInterval = setInterval(updateTimer, 100);
        }

        async function commitCurrentMove() {
            if (!gameId || !userId || !selectedCell || isMoveCommitted) return;
            isMoveCommitted = true; 
            try {
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    [`players.${userId}.lastMove`]: selectedCell
                });
            } catch (e) { console.error("Failed to commit move:", e); }
        }

        function getStrategicAIMove(board, playerObj, color) {
            let possibleMoves = [];
            const emptyCells = [];
            const enemyCells = [];
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if (board[r][c] === '') emptyCells.push({r, c});
                    else if (board[r][c] !== color) enemyCells.push({r, c});
                }
            }
            emptyCells.forEach(cell => {
                const flips = applyOthello(board, cell.r, cell.c, color);
                possibleMoves.push({ r: cell.r, c: cell.c, isOverwrite: false, flips: flips.length, score: (flips.length * 10) + 20 });
            });
            if (playerObj.overwrites > 0) {
                enemyCells.forEach(cell => {
                    const flips = applyOthello(board, cell.r, cell.c, color);
                    let allowed = false;
                    if (emptyCells.length <= 8) allowed = true;
                    else if (emptyCells.length <= 16) { if (flips.length >= 2) allowed = true; }
                    else { if (flips.length >= 3) allowed = true; }
                    if (allowed) {
                        const urgencyBonus = (25 - emptyCells.length) * 1.5; 
                        let score = (flips.length * 12) + urgencyBonus; 
                        possibleMoves.push({ r: cell.r, c: cell.c, isOverwrite: true, flips: flips.length, score: score });
                    }
                });
            }
            possibleMoves.sort((a, b) => b.score - a.score);
            if (possibleMoves.length > 0) {
                 const bestScore = possibleMoves[0].score;
                 const topMoves = possibleMoves.filter(m => m.score >= bestScore - 5);
                 return topMoves[Math.floor(Math.random() * topMoves.length)];
            }
            return null;
        }

        async function resolveTurn(gameData) {
            if (isResolving) return;
            isResolving = true;
            let board = JSON.parse(gameData.board).map(r => [...r]);
            const players = gameData.players;
            let moves = [];
            for (const pid in players) {
                const p = players[pid]; 
                if (p.isAI) {
                    const aiMove = getStrategicAIMove(board, p, p.color);
                    if (aiMove) moves.push({ id: pid, color: p.color, r: aiMove.r, c: aiMove.c, isOverwrite: aiMove.isOverwrite });
                    else {
                        const rand = getRandomMove(board);
                        if(rand) moves.push({ id: pid, color: p.color, r: rand.r, c: rand.c, isOverwrite: false });
                    }
                } else {
                    if (p.lastMove) moves.push({ id: pid, color: p.color, r: p.lastMove.r, c: p.lastMove.c, isOverwrite: p.lastMove.isOverwrite });
                }
            }
            const movesAtPos = {};
            moves.forEach(m => {
                const key = `${m.r},${m.c}`;
                if(!movesAtPos[key]) movesAtPos[key] = [];
                movesAtPos[key].push(m);
            });
            const roundEvents = [];
            let totalAnimTime = 0;
            for (const key in movesAtPos) {
                const cellMoves = movesAtPos[key];
                const [r, c] = key.split(',').map(Number);
                if (cellMoves.length > 1) {
                    const colors = cellMoves.map(m => m.color);
                    roundEvents.push({ r, c, type: 'conflict', colors: colors });
                    // --- FIX: Faster Turn Resolution Calc ---
                    totalAnimTime += (colors.length * 550) + 550; // Was 500/500
                    board[r][c] = ''; 
                }
            }
            const overwriteConsumers = new Set();
            const validMoves = moves.filter(m => {
                if (movesAtPos[`${m.r},${m.c}`].length > 1) return false; 
                const currentOwner = board[m.r][m.c];
                if (m.isOverwrite) {
                    if (currentOwner === '' || currentOwner === m.color) return false; 
                    if (players[m.id].overwrites <= 0) return false; 
                    return true;
                } else { return currentOwner === ''; }
            });
            validMoves.forEach(m => {
                board[m.r][m.c] = m.color;
                roundEvents.push({ r: m.r, c: m.c, color: m.color, type: 'success' });
                totalAnimTime += 660; // Was 600
                if(m.isOverwrite) overwriteConsumers.add(m.id);
                const flips = applyOthello(board, m.r, m.c, m.color);
                flips.forEach(f => {
                    board[f.r][f.c] = m.color; 
                    roundEvents.push({ r: f.r, c: f.c, color: m.color, type: 'flip' });
                    totalAnimTime += 330; // Was 300
                });
            });
            let newScores = {};
            let finalFilled = 0;
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    const cell = board[r][c];
                    if(cell) { newScores[cell] = (newScores[cell] || 0) + 1; finalFilled++; }
                }
            }
            const updatedPlayers = {};
            for (const pid in players) {
                let p = players[pid];
                let newOverwrites = p.overwrites;
                if (overwriteConsumers.has(pid)) newOverwrites--;
                let isNowAI = p.isAI; let newNickname = p.nickname;
                if (gameData.turn === 1 && !p.isAI && !p.lastMove) { isNowAI = true; newNickname = `AI (AUTO)`; }
                updatedPlayers[pid] = { ...p, nickname: newNickname, isAI: isNowAI, lastMove: null, score: newScores[p.color] || 0, overwrites: newOverwrites };
            }
            const totalCells = BOARD_SIZE * BOARD_SIZE;
            const isEnd = finalFilled >= (totalCells - 1); 
            const nextDeadline = Date.now() + TURN_DURATION_MS + NETWORK_BUFFER_MS + totalAnimTime + 500;
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshSnap = await transaction.get(gameRef);
                    if (!freshSnap.exists()) throw "Game Over/Deleted";
                    const freshData = freshSnap.data();
                    if (freshData.turn > gameData.turn) return;
                    transaction.update(gameRef, {
                        board: JSON.stringify(board), players: updatedPlayers,
                        turn: gameData.turn + 1, turnDeadline: nextDeadline, status: isEnd ? 'finished' : 'playing',
                        lastRoundEvents: JSON.stringify(roundEvents)
                    });
                });
            } catch (e) { console.log("Turn resolution skipped:", e); }
            selectedCell = null; isResolving = false;
        }

        window.handleCellClick = async (r, c) => {
            if (!gameId || !myColor || isResolving || isAnimating || isMoveCommitted) return;
            const cellColor = currentBoardState[r][c];
            let isOverwrite = false;
            if (cellColor !== '') {
                if (cellColor === myColor) return; 
                if (myOverwritesLeft <= 0) return; 
                isOverwrite = true;
            }
            selectedCell = { r, c, isOverwrite };
            renderBoard(currentBoardState, { status: 'playing' }); 
        };

        function renderBoard(board, gameData) {
            const cells = boardElement.querySelectorAll('.cell');
            cells.forEach(el => el.remove());
            const waitingScreen = boardElement.querySelector('.col-span-5');
            if(gameData.status === 'playing') { if(waitingScreen) waitingScreen.classList.add('hidden'); }
            else if (gameData.status === 'finished') { if(waitingScreen) waitingScreen.classList.add('hidden'); }
            else { if(waitingScreen) waitingScreen.classList.remove('hidden'); }
            
            const frag = document.createDocumentFragment();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cellVal = board[r][c];
                    const div = document.createElement('div');
                    div.className = `cell w-full h-full flex items-center justify-center text-white font-bold text-lg`;
                    if (cellVal) {
                        div.className += ` ${COLOR_MAP[cellVal].code} occupied-immutable`;
                        if (gameData.status === 'playing' && myColor && cellVal !== myColor && myOverwritesLeft > 0) div.style.cursor = "crosshair";
                    } else div.classList.add('bg-white');
                    if (gameData.status === 'playing' && myColor && !isAnimating) {
                        if (selectedCell && selectedCell.r === r && selectedCell.c === c) {
                            div.className = `cell w-full h-full flex items-center justify-center text-white font-bold text-lg ${COLOR_MAP[myColor].code}`;
                            if (selectedCell.isOverwrite) div.classList.add('breaker-shine', 'ring-4', 'ring-inset', 'ring-black');
                            else div.classList.add('ring-4', 'ring-inset', 'ring-black/10');
                        } else {
                            const isEnemy = cellVal && cellVal !== myColor;
                            if (!cellVal || (isEnemy && myOverwritesLeft > 0)) div.onclick = () => window.handleCellClick(r, c);
                        }
                    }
                    frag.appendChild(div);
                }
            }
            boardElement.insertBefore(frag, boardElement.firstChild);
        }

        window.toggleFriendSelection = (id) => {
            if (selectedFriendIds.has(id)) selectedFriendIds.delete(id);
            else {
                if (selectedFriendIds.size >= 2) { alert("Max 2 friends."); return; }
                selectedFriendIds.add(id);
            }
            if(currentQueueDocs) renderQueueList(currentQueueDocs);
            if (selectedFriendIds.size === 2) startFriendsBtn.classList.remove('hidden');
            else startFriendsBtn.classList.add('hidden');
        };

        function watchOpenRooms() {
            if (unsubscribeOpenRooms) return;
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const q = query(gamesRef, where('status', '==', 'waiting'), limit(20));
            unsubscribeOpenRooms = onSnapshot(q, (snapshot) => {
                const listEl = document.getElementById('open-rooms-list');
                const countEl = document.getElementById('open-rooms-count');
                if(!listEl) return;
                const rooms = [];
                snapshot.forEach(doc => { rooms.push({ id: doc.id, ...doc.data() }); });
                countEl.textContent = rooms.length;
                if (rooms.length === 0) listEl.innerHTML = '<p class="text-gray-300 text-xs text-center py-4 uppercase tracking-widest">No Open Rooms</p>';
                else {
                    listEl.innerHTML = '';
                    rooms.forEach(room => {
                        const pCount = Object.keys(room.players).length;
                        const hostName = room.players[room.hostId]?.nickname || 'Unknown';
                        const isMyRoom = (room.players[userId] !== undefined);
                        const rName = room.roomName || 'Room';
                        const el = document.createElement('div');
                        el.className = "flex justify-between items-center p-3 border border-blue-100 bg-blue-50/50 mb-2 rounded hover:bg-blue-100 transition-colors cursor-pointer";
                        el.onclick = () => joinOpenGame(room.id);
                        if (isMyRoom) el.className += " border-blue-500 ring-1 ring-blue-500";
                        el.innerHTML = `<div><div class="text-sm font-black uppercase text-blue-700 leading-tight mb-0.5">${rName}</div><div class="text-[10px] text-gray-500 font-bold uppercase">HOST: ${hostName}</div></div><div class="flex flex-col items-end gap-1"><span class="text-lg font-black text-blue-600">${pCount}/3</span><span class="text-[10px] bg-blue-600 text-white px-2 py-0.5 rounded font-bold uppercase">JOIN</span></div>`;
                        listEl.appendChild(el);
                    });
                }
            });
        }

        async function createPublicRoom(roomName) {
            nicknameSection.classList.add('hidden');
            joinBtn.disabled = true; 
            boardElement.innerHTML = `<div class="col-span-5 flex flex-col items-center justify-center h-full bg-white text-black p-4 text-center"><h2 class="text-2xl font-black uppercase mb-2 text-yellow-600">${roomName}</h2><p class="text-sm font-bold text-gray-500 mb-4">Creating Room...</p><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-black"></div></div>`;
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'games');
            const newGameRef = doc(gamesRef);
            const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
            const playersData = { [userId]: { nickname: myNickname, color: 'R', isAI: false, score: 0, overwrites: MAX_OVERWRITES, lastMove: null } };
            await setDoc(newGameRef, {
                status: 'waiting', turn: 1, turnDeadline: 0, board: JSON.stringify(initialBoard), players: playersData,
                playerOrder: [userId], hostId: userId, roomName: roomName, createdAt: serverTimestamp(), lastRoundEvents: "[]"
            });
            enterGame(newGameRef.id);
        }

        async function joinOpenGame(targetGameId) {
            if (!myNickname) {
                const val = nicknameInput.value.trim();
                if(val) myNickname = val.toUpperCase().slice(0, 10);
                else { alert("Please enter a nickname first."); nicknameInput.focus(); return; }
            }
            if(window.SoundManager) window.SoundManager.init();
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', targetGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Game does not exist!";
                    const data = gameDoc.data();
                    if (data.status !== 'waiting') throw "Game already started or finished!";
                    const players = data.players;
                    const playerIds = Object.keys(players);
                    if (players[userId]) return; 
                    if (playerIds.length >= 3) throw "Room is full!";
                    const nextColorIndex = playerIds.length; 
                    const nextColor = COLORS[nextColorIndex];
                    players[userId] = { nickname: myNickname, color: nextColor, isAI: false, score: 0, overwrites: MAX_OVERWRITES, lastMove: null };
                    const newOrder = [...data.playerOrder, userId];
                    
                    // REFACTORED: Do NOT set status to 'playing'. Just add player.
                    transaction.update(gameRef, { players: players, playerOrder: newOrder });
                });
                enterGame(targetGameId);
            } catch (e) { console.error("Join Failed:", e); alert("Failed to join: " + e); }
        }

        function renderScoreboard(players) {
            scoreList.innerHTML = '';
            COLORS.forEach(colorCode => {
                const playerEntry = Object.entries(players).find(([uid, p]) => p.color === colorCode);
                let score = 0; let label = "EMPTY"; let isMe = false; let overwrites = 0;
                if (playerEntry) {
                    const [uid, p] = playerEntry; score = p.score; overwrites = p.overwrites;
                    if (p.isAI) label = p.nickname; else if (uid === userId) { label = p.nickname + " (YOU)"; isMe = true; } else label = p.nickname;
                }
                const li = document.createElement('li');
                li.className = "flex justify-between items-center p-3 bg-white border border-gray-100 shadow-sm";
                li.innerHTML = `<div class="flex items-center gap-3"><div class="w-4 h-4 rounded-full ${COLOR_MAP[colorCode].code}"></div><div class="flex flex-col"><span class="text-sm font-bold uppercase tracking-wider ${isMe ? 'text-black' : 'text-gray-600'}">${label}</span>${playerEntry ? `<span class="text-[10px] text-gray-400">BREAKERS: ${overwrites}</span>` : ''}</div></div><span class="font-mono font-black text-xl">${score}</span>`;
                scoreList.appendChild(li);
            });
        }
        
        function applyOthello(board, r, c, color) {
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
            let flippedCells = [];
            dirs.forEach(([dr, dc]) => {
                let nr = r + dr, nc = c + dc, flippable = [];
                let foundOwnColor = false;
                while(nr>=0 && nr<BOARD_SIZE && nc>=0 && nc<BOARD_SIZE) {
                    const cellColor = board[nr][nc];
                    if(cellColor === '') break; 
                    if(cellColor === color) { foundOwnColor = true; break; }
                    flippable.push({r:nr, c:nc});
                    nr += dr; nc += dc;
                }
                if(foundOwnColor) flippedCells = flippedCells.concat(flippable);
            });
            return flippedCells;
        }

        function getRandomMove(board) {
            let empties = [];
            for(let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) if(board[r][c] === '') empties.push({r,c});
            return empties.length ? empties[Math.floor(Math.random()*empties.length)] : null;
        }

        function showWinner(players) {
             const winner = Object.values(players).sort((a, b) => b.score - a.score)[0];
             const myScore = players[userId]?.score || 0;
             const isWin = players[userId] && winner.color === players[userId].color;
             const title = isWin ? "VICTORY" : "GAME OVER";
             const content = `WINNER: ${winner.nickname} (${winner.score})\nYOUR SCORE: ${myScore}`;
             document.getElementById('modal-title').textContent = title;
             document.getElementById('modal-content').textContent = content;
             // Force display
             const modal = document.getElementById('message-modal');
             modal.classList.remove('hidden');
        }

        window.triggerRematch = async () => {
             document.getElementById('message-modal').classList.add('hidden');
             if (!gameId) return;
             document.getElementById('modal-content').textContent = "Restarting...";
             const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
             const deadLine = Date.now() + FIRST_TURN_DURATION_MS + NETWORK_BUFFER_MS;
             const initialBoard = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(''));
             try {
                 await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(gameRef);
                    if (!sfDoc.exists()) return;
                    const data = sfDoc.data();
                    const players = data.players;
                    const newPlayers = {};
                    for (const pid in players) {
                        newPlayers[pid] = { ...players[pid], score: 0, overwrites: MAX_OVERWRITES, lastMove: null };
                    }
                    transaction.update(gameRef, { status: 'playing', turn: 1, turnDeadline: deadLine, board: JSON.stringify(initialBoard), players: newPlayers, lastRoundEvents: "[]" });
                 });
             } catch (e) { console.error("Rematch failed:", e); resetLocalStateAndUI(); }
        };

        function setupPlayAgainListener() {
            const btn = document.getElementById('modal-play-again');
            if(btn) btn.onclick = () => window.triggerRematch();
        }
        setupPlayAgainListener();
    </script>
</body>
</html>